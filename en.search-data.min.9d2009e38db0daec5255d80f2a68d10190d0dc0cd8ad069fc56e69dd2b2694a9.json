[{"id":0,"href":"/docs/program-language/","title":"Program Language","section":"Docs","content":""},{"id":1,"href":"/docs/program-language/python/","title":"Python","section":"Program Language","content":"\rPYTHON\r#\rPython Document ✈️\n"},{"id":2,"href":"/docs/program-language/python/spider/","title":"Spider","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":3,"href":"/docs/program-language/python/spider/css_selector/","title":"Css_selector","section":"Spider","content":"\rCSS_LELECTOR\r#\rspan\u0026gt;span[name:value] span:: .class1.class2 # 一个标签多个class span.classname # span标签特定classname spanname[name=value] # 属性值定位 属性名=属性值 [id=\u0026#34;IamID\u0026#34;][name=\u0026#34;first\u0026#34;] # 多属性定位 .form span # class=from 下所有子孙 span 标签 .form\u0026gt;span # class=from 下所有下一级 span 标签 .Dream + br # 只能向后一个选择同级标签 .Dream ~ br # 向后选择同级标签 :nth-child(n) # 匹配属于其父元素下的第n个子元素 option:nth-child(3) # option标签的父标签的第三个子元素 :nth-last-child(n) # 匹配属于其父元素下的倒数第n个子元素 :first-child # 匹配属于其父元素下的第1个子元素 :last-child # 匹配属于其父元素下的最后1个子元素 # class值一样 id随机生成 # :contains() 访问页面上DOM tree之外的信息 \u0026#39;.xbutton:contains(\u0026#34;OK\u0026#34;)\u0026#39; # 定位class为 xbutton 的一个显示OK的Button div[class=\u0026#39;u-input box]\u0026gt;input:nth-child(2) "},{"id":4,"href":"/docs/","title":"Docs","section":"Introduction","content":""},{"id":5,"href":"/docs/program-language/python/spider/execjs/","title":"Execjs","section":"Spider","content":"\rEXECJS\r#\rpip install pyexecjs2 "},{"id":6,"href":"/docs/program-language/python/spider/xpath/","title":"Xpath","section":"Spider","content":"\rXPATH\r#\rfrom lxml import etree text = \u0026#39;html reponse text\u0026#39; html = etree.HTML(text) result:list = html.xpath(\u0026#39;//div[@id=\u0026#34;s-top-left\u0026#34;]//a[text()=\u0026#34;学术\u0026#34;]\u0026#39;) # div id 为 s-top-left 的下面 所有的 a 标签的 文本 为 学术 # nodename 选取此节点的所有子节点 bookstore # 选取 bookstore 元素的所有子节点 # / 从根节点选取（取子节点） # 假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ /bookstore # 选取根元素 bookstore bookstore/book # 选取属于 bookstore 的子元素的所有 book 元素 # // 从匹配选择的当前节点选择文档中的节点 //book # 选取所有 book 子元素，而不管它们在文档中的位置 bookstore//book # 选择属于 bookstore 元素的所有 book 元素 # 取值 ./text() # 只取当前节点中的文本内容 对于子孙节点的内容不会取 .//text() # 取当前节点及其子孙节点中的文本内容 . # 选取当前节点。 .. # 选取当前节点的父节点。 @ # 选取属性。 //@lang # 选取名为 lang 的所有属性。 //title[@lang=\u0026#39;eng\u0026#39;] # 选取所有值为 eng 的 lang 属性的 title 元素 /bookstore/book[1] # 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] # 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] # 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()\u0026lt;3] # 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 /bookstore/book[price\u0026gt;35.00] # 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price\u0026gt;35.00]//title # 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 * # 匹配任何元素节点。 /bookstore/* # 选取 bookstore 元素的所有子元素。 @* # 匹配任何属性节点 //* # 选取文档中的所有元素。 //title[@*] # 选取所有带有属性的 title 元素。 node() # 匹配任何类型的节点 //book/title | //book/price # 选取 book 元素的所有 title 和 price 元素。 "},{"id":7,"href":"/docs/program-language/python/features/","title":"Features","section":"Python","content":"\rFEATURES\r#\rF-string\r#\rf'{expr=}' 的 f-字符串将扩展表示为表达式文本，加一个等于号，再加表达式的求值结果\n指定了转换符，表达式的求值结果会先转换再格式化\ndes = \u0026#39;string\u0026#39; f\u0026#39;this is a {des}\u0026#39; # this is a string f\u0026#39;{des = }\u0026#39; # des = string # \u0026#39;!r\u0026#39; 为调用 repr() name = \u0026#34;Fred\u0026#34; f\u0026#34;He said his name is {name!r}.\u0026#34; # \u0026#34;He said his name is \u0026#39;Fred\u0026#39;.\u0026#34; # \u0026#39;!s\u0026#39; 即对结果调用 str() # \u0026#39;!a\u0026#39; 为调用 ascii() width = 10 precision = 4 value = decimal.Decimal(\u0026#34;12.34567\u0026#34;) f\u0026#34;result: {value:{width}.{precision}}\u0026#34; # nested fields \u0026#39;result: 12.35\u0026#39; today = datetime(year=2017, month=1, day=27) f\u0026#34;{today:%B %d, %Y}\u0026#34; # using date format specifier \u0026#39;January 27, 2017\u0026#39; f\u0026#34;{today=:%B %d, %Y}\u0026#34; # using date format specifier and debugging \u0026#39;today=January 27, 2017\u0026#39; number = 1024 f\u0026#34;{number:#0x}\u0026#34; # using integer format specifier \u0026#39;0x400\u0026#39; foo = \u0026#34;bar\u0026#34; f\u0026#34;{ foo = }\u0026#34; # preserves whitespace \u0026#34; foo = \u0026#39;bar\u0026#39;\u0026#34; line = \u0026#34;The mill\u0026#39;s closed\u0026#34; f\u0026#34;{line = :20}\u0026#34; # \u0026#34;line = The mill\u0026#39;s closed \u0026#34; f\u0026#34;{line = !r:20}\u0026#34; # \u0026#39;line = \u0026#34;The mill\\\u0026#39;s closed\u0026#34; \u0026#39; 变量注释\r#\r函数声明中的各个参数可以在：后增加注解表达式\n参数由默认值，注解放在参数名和 = 号之间\n注解返回值，在)和函数末尾的:之间增加 -\u0026gt; 和一个表达式。可以是任何类型。注解中最常用的类型是类（如 str 或 int）和字符串（如 int \u0026gt; 0）。\nprimes: List[int] = [] captain: str class Starship: stats: Dict[str, int] = {} def sum(a:int,b: int = 20)-\u0026gt; int:pass 数字文字中的下划线\r#\r1_000_000_000_000_000 # 1000000000000000 0x_FF_FF_FF_FF # 4294967295 海象赋值\r#\r在表达式内部为变量赋值\nif (n := len(a)) \u0026gt; 10:# 赋值表达式可以避免调用 len() 两次: print(f\u0026#34;List is too long ({n} elements, expected \u0026lt;= 10)\u0026#34;) discount = 0.0 # 在正则中需要使用两次匹配对象，一次检测用于匹配是否发生，另一次用于提取子分组: if (mo := re.search(r\u0026#39;(\\d+)% discount\u0026#39;, advertisement)): discount = float(mo.group(1)) / 100.0 # 配合 while 循环计算一个值来检测循环是否终止，而同一个值又在循环体中再次被使用的情况 while (block := f.read(256)) != \u0026#39;\u0026#39;: process(block) # 列表推导式中，在筛选条件中计算一个值，而同一个值又在表达式中需要被使用: [clean_name.title() for name in names if (clean_name := normalize(\u0026#39;NFC\u0026#39;, name)) in allowed_names] 仅限位置形参\r#\r/ 用来指明某些函数形参必须使用仅限位置而非关键字参数的形式\n# a 和 b 为仅限位置形参，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参 def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) f(10, 20, 30, d=40, e=50, f=60) # 在 / 左侧的形参不会被公开为可用关键字，其他形参名仍可在 **kwargs 中使用 def f(a, b, /, **kwargs): print(a, b, kwargs) f(10, 20, a=1, b=2, c=3) # 10 20 {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 字典合并与更新运算符\r#\r合并 (|) 与更新 (|=) 运算符已被加入内置的 dict 类。 它们为现有的 dict.update 和 {**d1, **d2} 字典合并方法提供了补充。\nx = {\u0026#34;key1\u0026#34;: \u0026#34;value1 from x\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;value2 from x\u0026#34;} y = {\u0026#34;key2\u0026#34;: \u0026#34;value2 from y\u0026#34;, \u0026#34;key3\u0026#34;: \u0026#34;value3 from y\u0026#34;} x | y # {\u0026#39;key1\u0026#39;: \u0026#39;value1 from x\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2 from y\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3 from y\u0026#39;} y | x # {\u0026#39;key2\u0026#39;: \u0026#39;value2 from x\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3 from y\u0026#39;, \u0026#39;key1\u0026#39;: \u0026#39;value1 from x\u0026#39;} 移除前缀和后缀的字符串方法\r#\r# str.removeprefix(prefix, /) # 字符串以 prefix 字符串开头，返回 string[len(prefix):]。 否则，返回原始字符串的副本 \u0026#39;TestHook\u0026#39;.removeprefix(\u0026#39;Test\u0026#39;) # \u0026#39;Hook\u0026#39; \u0026#39;BaseTestCase\u0026#39;.removeprefix(\u0026#39;Test\u0026#39;) # \u0026#39;BaseTestCase\u0026#39; # str.removesuffix(suffix, /) # 如果字符串以 suffix 字符串结尾，并且 suffix 非空，返回 string[:-len(suffix)]。 否则，返回原始字符串的副本 \u0026#39;MiscTests\u0026#39;.removesuffix(\u0026#39;Tests\u0026#39;) # \u0026#39;Misc\u0026#39; \u0026#39;TmpDirMixin\u0026#39;.removesuffix(\u0026#39;Tests\u0026#39;) # \u0026#39;TmpDirMixin\u0026#39; 带圆括号的上下文管理器\r#\r支持使用外层圆括号来使多个上下文管理器可以连续多行地书写。 这允许将过长的上下文管理器集能够以与之前 import 语句类似的方式格式化为多行的形式\nwith (CtxManager() as example): ... with ( CtxManager1(), CtxManager2() ): ... with (CtxManager1() as example, CtxManager2()): ... with (CtxManager1(), CtxManager2() as example): ... with ( CtxManager1() as example1, CtxManager2() as example2 ): ... 结构化模式匹配\r#\r接受一个表达式并将其值与以一个或多个 case 语句块形式给出的一系列模式进行比较\nmatch subject: case \u0026lt;pattern_1\u0026gt;: \u0026lt;action_1\u0026gt; case \u0026lt;pattern_2\u0026gt;: \u0026lt;action_2\u0026gt; case \u0026lt;pattern_3\u0026gt;: \u0026lt;action_3\u0026gt; case _: # _ 匹配任何 \u0026lt;action_wildcard\u0026gt; # 没有匹配成功，在 _ 的最后一个 case 语句，则它将被用作已匹配模式。 # 如果match 没有匹配成功， 并不存在 _ 通配符， 则忽略整个匹配语句 简单模式：匹配一个字面值\r#\r变量名_将作为 通配符 并确保目标将总是被匹配。_ 的使用是可选的。\n使用 | （“ or ”）在一个模式中组合几个字面值:\ndef http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 401 | 403 | 404: # 使用 | （“ or ”）在一个模式中组合几个字面值: return \u0026#34;Not allowed\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: # status 为 418，则会返回 \u0026#34;I\u0026#39;m a teapot\u0026#34; return \u0026#34;I\u0026#39;m a teapot\u0026#34; case _: # status 为 500，则带有 _ 的 case 语句将作为通配符匹配 return \u0026#34;Something\u0026#39;s wrong with the internet\u0026#34; 无通配符的行为\r#\r如果不在 case 语句中使用 _，可能会出现不存在匹配的情况。如果不存在匹配，则行为是一个 no-op\ndef http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: return \u0026#34;I\u0026#39;m a teapot\u0026#34; 带有字面值和变量的模式\r#\r模式可以看起来像解包形式，而且模式可以用来绑定变量\n# point is an (x, y) tuple match point: case (0, 0): print(\u0026#34;Origin\u0026#34;) case (0, y): print(f\u0026#34;Y={y}\u0026#34;) case (x, 0): print(f\u0026#34;X={x}\u0026#34;) case (x, y): print(f\u0026#34;X={x}, Y={y}\u0026#34;) case _: raise ValueError(\u0026#34;Not a point\u0026#34;) # 第一个模式有两个字面值 (0, 0) ，可以看作是上面所示字面值模式的扩展。 # 接下来的两个模式结合了一个字面值和一个变量，而变量 绑定 了一个来自主词的值（point）。 # 第四种模式捕获了两个值，这使得它在概念上类似于解包赋值 (x, y) = point 。 模式和类\r#\rclass Point: x: int y: int def location(point): match point: case Point(x=0, y=0): print(\u0026#34;Origin is the point\u0026#39;s location.\u0026#34;) case Point(x=0, y=y): print(f\u0026#34;Y={y} and the point is on the y-axis.\u0026#34;) case Point(x=x, y=0): print(f\u0026#34;X={x} and the point is on the x-axis.\u0026#34;) case Point(): print(\u0026#34;The point is located somewhere else on the plane.\u0026#34;) case _: print(\u0026#34;Not a point\u0026#34;) 复杂模式和通配符\r#\rmatch test_variable: case (\u0026#39;warning\u0026#39;, code, 40): print(\u0026#34;A warning has been received.\u0026#34;) case (\u0026#39;error\u0026#39;, code, _): print(f\u0026#34;An error {code} occurred.\u0026#34;) 约束项\r#\r可以向一个模式添加 if 子句，称为“约束项”。\n如果约束项为假值，则 match 将继续尝试下一个 case 语句块。 请注意值的捕获发生在约束项被求值之前 match point: case Point(x, y) if x == y: print(f\u0026#34;The point is located on the diagonal Y=X at {x}.\u0026#34;) case Point(x, y): print(f\u0026#34;Point is not on the diagonal.\u0026#34;) "},{"id":8,"href":"/docs/program-language/python/basic/","title":"Basic","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":9,"href":"/docs/program-language/python/basic/async/","title":"Async","section":"Basic","content":"\rASYNC\r#\rAIOHTTP\nasync \u0026amp; await 关键字\n在一个线程中遇到io等待时间，利用空闲的时间运行其他代码\nimport asyncio, aiohttp async def fetch(session, url): async with session.get(url, verify_ssl = False) as response: content = await response.content.read() # 可等待对象 file_name = url.rsplit(\u0026#39;_\u0026#39;)[-1] with open(file_name,\u0026#39;wb\u0026#39;) as f: f.write(content) async def main(): async with aiohttp.ClientSession() as session: url_list = [\u0026#39;http:sadadasdada_sadadsa.jpg\u0026#39;] tasks = [ async.creat_task( fetch(session,url)) for url in url_list ] await async.wait(tasks) if __name__ == \u0026#39;__main__\u0026#39;: asyncio.run( main() ) async\r#\rimport asyncio async def run(): # 协程函数 print(1) result = run() # run() 协程对象 单独main()函数内部不会运行 asyncio.run(result) # 事件循环函数 await\r#\rawait + 可等待对象( 协程对象、Future、Task对象)\n等待 等待的对象 得到结果之后继续执行\nimport asyncio async def runc(): print(\u0026#39;1\u0026#39;) response = await asyncio.sleep(2) print(3) asyncio.run(func()) import asyncio async def other(): print(\u0026#39;start\u0026#39;) await asyncio.sleep(2) print(\u0026#39;end\u0026#39;) return \u0026#39;return\u0026#39; async def func(): print(\u0026#39;协程函数\u0026#39;) response = await other() print(\u0026#39;io finisg\u0026#39;,response) asyncio.run(func()) import asyncio async def other(): print(\u0026#39;start\u0026#39;) await asyncio.sleep(2) print(\u0026#39;end\u0026#39;) return \u0026#39;return\u0026#39; async def func(): print(\u0026#39;协程函数\u0026#39;) response1 = await other() # 等待执行完毕后才会继续执行下方代码 print(\u0026#39;io1 finisg\u0026#39;,response1) response2 = await other() # res1 获取返回值后才会执行 print(\u0026#39;io2 finisg\u0026#39;,response2) asyncio.run(func()) task 对象\r#\rimport asyncio async def func(): print(1) await asyncio.sleep(2) print(2) return \u0026#39;return\u0026#39; async def main(): print(\u0026#39;main init\u0026#39;) # 创建task对象， 将当前执行func函数任务添加到事件循环 task1 = asyncio.create_task(func()) task2 = asyncio.create_task(func()) print(\u0026#39;mian over\u0026#39;) ret1 = await task1 ret2 = await task2 print(ret1,ret2) asyncio.run(main()) import asyncio async def func(): print(1) await asyncio.sleep(2) print(2) return \u0026#39;return\u0026#39; async def main(): print(\u0026#39;main init\u0026#39;) task_list = [ asyncio.create_task(func()[,name=\u0026#39;name\u0026#39;]), asyncio.create_task(func()) ] print(\u0026#39;mian over\u0026#39;) done,pendding = await asyncio.wait(task_list) print(\u0026#39;done\u0026#39;) asyncio.run(main()) asyncio 和 不支持异步的模块\r#\rimport asyncio,requests async def download(url): loop = asyncio.get_event_loop() future = loop.run_in_executor(None,requests.get,url) response = await future print(\u0026#39;download success\u0026#39;) with open(\u0026#39;filename\u0026#39;,\u0026#39;w\u0026#39;) as f: f.write(response.content) if __name__ == \u0026#39;__main__\u0026#39;: url_list = [\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;] tasks = [download(url) for url in url_list] asyncio.run(asyncio.wait(tasks)) 异步迭代器\r#\rclass Reader(object): def __init__(self) -\u0026gt; None: self.count = 0 async def readline(self): self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return val async def func(): obj = Reader() async for item in obj: print(item) asyncio.run(func()) 异步上下文管理器\r#\r通过定义 __aenter__()和 __aexit__() 方法来对 async with 语句中的环境进行控制\nclass AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await ... return self async def __aexit__(self): # 异步关闭数据库 await .... async def func(): async with AsyncContextManager() as f: result = await f.do_something() asyncio.run( func() ) uvlook\r#\rasyncio 事件循环的替代方案。 事件循环效率 \u0026gt; 默认 asyncio 的事件循环\nimport uvlook # pip install uvlook asynico.set_event_loop_policy(uvlook.EventLoopPolicy()) # 编写 asyncio代码 和之前一样 asyncio.run(...) # 会把 asyncio的循环自动转换成 uvlook 异步操作redis\r#\r# pip install aioredis async def execute(add,pw): print(\u0026#39;start\u0026#39;) # 网络io操作 链接数据库 redis = await aioredis.create_redis(add,password=pw) # 网络io操作 在redis中设置 哈希值 car， 内部再设三个兼职对 # 即 redis = { car: {key1:1,key2:2,...}} await redis.hmset_dict(\u0026#39;car\u0026#39;,key=1,key2=2) # 网络io操作 去redis中获取值 result = await redis.hgetall(\u0026#39;car\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) print(result) redis.close() # 网络io操作 关闭redis链接 await redis.wait_clised() print(\u0026#39;finish\u0026#39;,add) asyncio.run( execute(\u0026#39;redis://0.0.0.0:00\u0026#39;,\u0026#39;root!12\u0026#39;) ) 异步操作mysql\r#\r# pip install aiomysql import asyncio,aiomysql async def execute(): print(\u0026#39;start\u0026#39;) # 链接 mysql conn = await aiomysql.connect(host=\u0026#39;\u0026#39;,port=\u0026#39;\u0026#39;,user=\u0026#39;\u0026#39;,password=\u0026#39;\u0026#39;,db=\u0026#39;\u0026#39;) # 创建cursor cur = await conn.cursor() # 执行 sql await cur.execute(\u0026#39;SELECT host,User FROM user\u0026#39;) # 获取结果 result = await cur.fetchall() print(result) # 关闭链接 await cur.close() conn.close() asyncio.run( execute() ) async def execute(host,password): print(\u0026#39;start\u0026#39;) # 链接 mysql conn = await aiomysql.connect(host=host,port=\u0026#39;\u0026#39;,user=\u0026#39;\u0026#39;,password=password,db=\u0026#39;\u0026#39;) # 创建cursor cur = await conn.cursor() # 执行 sql await cur.execute(\u0026#39;SELECT host,User FROM user\u0026#39;) # 获取结果2 result = await cur.fetchall() print(result) # 关闭链接 await cur.close() conn.close() task_list = [ execute(\u0026#39;0.0.0.0\u0026#39;,\u0026#39;root!1234\u0026#39;), execute(\u0026#39;0.0.0.1\u0026#39;,\u0026#39;root!1234\u0026#39;) ] asyncio.run( asyncio.wait(task_list) ) fastapi框架\r#\r# pip install fastapi # pip install uvicorn (asgi内部基于uvloop) "},{"id":10,"href":"/posts/","title":"Blog","section":"Introduction","content":""},{"id":11,"href":"/posts/taobao/","title":"Taobao","section":"Blog","content":"website taobao spider\nscrapy startproject projectname cd projectname scrapy genspider spidername spiderwebsite pip install -r requirements.txt 创建浏览器\r#\rfrom selenium import webdriver from selenium.webdriver.chrome.service import Service as ChromeService def creat_chrome_driver(*,headless=False): option = webdriver.Options() if headless: options.add_argument(\u0026#39;--headless\u0026#39;) options.add_experimental_option(\u0026#39;excludeSwitches\u0026#39;,[\u0026#39;enable-automation\u0026#39;]) options.add_experimental_option(\u0026#39;useAutomationExtension\u0026#39;,False) browser = webdriver.Chrome(options=options) browser.execute_cdp_cmd( \u0026#39;Page.addScriptToEvaluateOnNewDocument\u0026#39;, {\u0026#39;source\u0026#39;:\u0026#39;Object.defineProperty(navigator,\u0026#34;webdriver\u0026#34;,{get: () =\u0026gt; undefined})\u0026#39;} ) return browser def add_cookies(browser,cookie_file): with open(cookie_file,\u0026#39;r\u0026#39;) as f: cookie_list = json.load(f) for cookie_dict in cookies_list: if cookie_dict[\u0026#39;secure\u0026#39;]: browser.add_cookie(cookie_dict) 从浏览器获取cookie\r#\rbrowser = creat_chrome_driver() browser.get(\u0026#39;https://login.taobao.com\u0026#39;) # 隐式等待 browser.implicitly_wait(10) user_input = browser.find_element(By.CSS_SELECTOR,\u0026#39;#\u0026#39;) user_input.send_keys(\u0026#39;name\u0026#39;) ... login_button.click() with open(\u0026#39;taobao.json\u0026#39;,\u0026#39;w\u0026#39;) as f: json.dump(browser.get_cookies(),f) 访问淘宝页面 并设置cookie\r#\rbrowser = creat_chrome_driver() browser.get(\u0026#39;https:www/taobao.com\u0026#39;) add_cookies(browser,\u0026#39;taobao.json\u0026#39;) browser.get(\u0026#39;https://s.taobao.com/search?q\u0026#39;) Items.py\r#\rclass a: title = scrapy.Field() ..... Spider.py\r#\rdef start_requests(self): keywords = [key1, key2] for key in keywords: for page in range(2): url = f\u0026#39;https://s.taobao.com/search?q{key}\u0026amp;s={page * 48}\u0026#39; # 一页48数据 yield scrapy.Request(url = url) Middlewares.py\r#\rdef __inti__(self): self.browser = creat_chrome_driver(headless=True) self.browser.get(\u0026#39;https://www.taobao.com\u0026#39;) add_cookies(self.browser,\u0026#39;taobao.json\u0026#39;) def __del__(self) : self.browser.close() def process_request(self,request,spider): self.browser.get(requests.url) return HtmlResponse(url=request.url,body=self.browser.page_source,request=request,encoding=\u0026#39;utf-8\u0026#39;) # 拿到动态加载的网页代码，返回响应体 Setting.py\r#\rDOWNLOADER_MIDDLEWARES = { \u0026#39;mySpider.middlewares.MyspiderDownloaderMiddleware\u0026#39;: 543, } "},{"id":12,"href":"/docs/program-language/python/basic/multiprocessing/","title":"Multiprocessing","section":"Basic","content":"\rMULTIPROCESSING\r#\r多进程 适合 利用计算机的多核优势 ，让cpu同时处理一些任务， 适合多进程开发(资源开销大)\n计算密集型 大量的数据计算\nimport multiprocessing def task(start,end,queue): result =0 for i in range(start,end): result += i queue.put(result) if __name__ == \u0026#39;__main__\u0026#39;: queue = multiprocessing.Queue() start_time = time.time() # 创建两个进程分别处理数据 p1 = multiprocessing.Process(target=task,args=(0,50000,queue)) p1.start() p2 = multiprocessing.Process(target=task,args=(50000,100000,queue)) p2.start() v1 = queue.get(block=True) v2 = queue.get(block=True) print(v1+v2) end_time = time.time() print(f\u0026#39;cost time : {end_time - start_time}\u0026#39;) win 下 多进程 需要写入 main 语句下 为 spawn 模式\n"},{"id":13,"href":"/docs/program-language/python/basic/threading/","title":"Threading","section":"Basic","content":"\rTHREADING\r#\r多线程 不利用计算机的多核优势， 适合多线程 IO密集型 文件读写 网络数据传输\nlist = [(\u0026#39;name1\u0026#39;,\u0026#39;url\u0026#39;), (\u0026#39;name2\u0026#39;,\u0026#39;url\u0026#39;), (\u0026#39;name3\u0026#39;,\u0026#39;url\u0026#39;)] def task(name,url): res = requests.get(url) with open(name,\u0026#39;wb\u0026#39;) as f: f.write(res.content) for name,url in list: # 创建线程，让每个线程都去执行函数 (参数不同) t = threading.Thread(target=task,args=(name,url)) t.start() # 创建新的线程 并把任务加入线程池进行任务(后台任务)， 不影响当前循环 "},{"id":14,"href":"/docs/program-language/python/data/","title":"Data","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":15,"href":"/docs/program-language/python/data/math/","title":"Math","section":"Data","content":"\rMATH\r#\rimport math 常量\r#\rmath.e # 返回欧拉数 (2.7182...) math.inf # 返回正无穷大浮点数 math.nan # 返回一个浮点值 NaN (not a number) math.pi # π 一般指圆周率。 圆周率 PI (3.1415...) math.tau # 数学常数 τ = 6.283185...，精确到可用精度。Tau 是一个圆周常数，等于 2π，圆的周长与半径之比。 FUNCTION\r#\rmath.acos(x) # 返回 x 的反余弦，结果范围在 0 到 pi 之间。 math.acosh(x) # 返回 x 的反双曲余弦值。 math.asin(x) # 返回 x 的反正弦值，结果范围在 -pi/2 到 pi/2 之间。 math.asinh(x) # 返回 x 的反双曲正弦值。 math.atan(x) # 返回 x 的反正切值，结果范围在 -pi/2 到 pi/2 之间。 math.atan2(y, x) # 返回给定的 X 及 Y 坐标值的反正切值，结果是在 -pi 和 pi 之间。 math.atanh(x) # 返回 x 的反双曲正切值。 math.ceil(x) # 将 x 向上舍入到最接近的整数 math.comb(n, k) # 返回不重复且无顺序地从 n 项中选择 k 项的方式总数。 math.copysign(x, y) # 返回一个基于 x 的绝对值和 y 的符号的浮点数。 math.cos() # 返回 x 弧度的余弦值。 math.cosh(x) # 返回 x 的双曲余弦值。 math.degrees(x) # 将角度 x 从弧度转换为度数。 math.dist(p, q) # 返回 p 与 q 两点之间的欧几里得距离，以一个坐标序列（或可迭代对象）的形式给出。 两个点必须具有相同的维度。 math.erf(x) # 返回一个数的误差函数 math.erfc(x) # 返回 x 处的互补误差函数 math.exp(x) # 返回 e 的 x 次幂，Ex， 其中 e = 2.718281... 是自然对数的基数。 math.expm1() # 返回 Ex - 1， e 的 x 次幂，Ex，其中 e = 2.718281... 是自然对数的基数。这通常比 math.e ** x 或 pow(math.e, x) 更精确。 math.fabs(x) # 返回 x 的绝对值。 math.factorial(x) # 返回 x 的阶乘。 如果 x 不是整数或为负数时则将引发 ValueError。 math.floor() # 将数字向下舍入到最接近的整数 math.fmod(x, y) # 返回 x/y 的余数 math.frexp(x) # 以 (m, e) 对的形式返回 x 的尾数和指数。 m 是一个浮点数， e 是一个整数，正好是 x == m * 2**e 。 如果 x 为零，则返回 (0.0, 0) ，否则返回 0.5 \u0026lt;= abs(m) \u0026lt; 1 。 math.fsum(iterable) # 返回可迭代对象 (元组, 数组, 列表, 等)中的元素总和，是浮点值。 math.gamma(x) # 返回 x 处的伽马函数值。 math.gcd() # 返回给定的整数参数的最大公约数。 math.hypot() # 返回欧几里得范数，sqrt(sum(x**2 for x in coordinates))。 这是从原点到坐标给定点的向量长度。 math.isclose(a,b) # 检查两个值是否彼此接近，若 a 和 b 的值比较接近则返回 True，否则返回 False。。 math.isfinite(x) # 判断 x 是否有限，如果 x 既不是无穷大也不是 NaN，则返回 True ，否则返回 False 。 math.isinf(x) # 判断 x 是否是无穷大，如果 x 是正或负无穷大，则返回 True ，否则返回 False 。 math.isnan() # 判断数字是否为 NaN，如果 x 是 NaN（不是数字），则返回 True ，否则返回 False 。 math.isqrt() # 将平方根数向下舍入到最接近的整数 math.ldexp(x, i) # 返回 x * (2**i) 。 这基本上是函数 math.frexp() 的反函数。 math.lgamma() #返回伽玛函数在 x 绝对值的自然对数。 math.log(x[, base]) # 使用一个参数，返回 x 的自然对数（底为 e ）。 math.log10(x) # 返回 x 底为 10 的对数。 math.log1p(x) # 返回 1+x 的自然对数（以 e 为底）。 math.log2(x) # 返回 x 以 2 为底的对数 math.perm(n, k=None) # 返回不重复且有顺序地从 n 项中选择 k 项的方式总数。 math.pow(x, y) # 将返回 x 的 y 次幂。 math.prod(iterable) # 计算可迭代对象中所有元素的积。 math.radians(x) # 将角度 x 从度数转换为弧度。 math.remainder(x, y) # 返回 IEEE 754 风格的 x 除于 y 的余数。 math.sin(x) # 返回 x 弧度的正弦值。 math.sinh(x) # 返回 x 的双曲正弦值。 math.sqrt(x) # 返回 x 的平方根。 math.tan(x) # 返回 x 弧度的正切值。 math.tanh(x) # 返回 x 的双曲正切值。 math.trunc(x) # 返回 x 截断整数的部分，即返回整数部分，删除小数部分 "},{"id":16,"href":"/docs/program-language/javascript/","title":"Javascript","section":"Program Language","content":"\rJavascript\r#\rHelloWorld\r#\rconsole.log(\u0026#39;HelloWorld\u0026#39;) "},{"id":17,"href":"/docs/program-language/javascript/basic/","title":"Basic","section":"Javascript","content":"\rBASIC\r#\r数据类型\r#\rnull 为空值 undefined 未定义 用于比较不存在的属性或值\nObject 对象\r#\r是以键值对的形式存在， key 都是字符串类型， value可以是任意类型\nlet obj = { name : \u0026#39;cxxx\u0026#39; }; let obj2 = obj // 浅拷贝 let obj3 = JSON.parse(JSON.stringfify(obj)) // 深拷贝 obj.title = \u0026#39;tit\u0026#39; # 添加 Object.keys(obj) # 获取所有keys Object.values(obj) # 获取所有值 for ( let key in obj ){ if (obj.hasOwnProperty(key)){ const value = obj[key] } } Array 数组\r#\r是一个有序的集合， 值可以是任意类型\nlet items = [1,2,3] items[index] # index 取值 items[index] = value # 赋值 items.length # 获取长度 items.push(value) # 添加元素 itemssplice( 0, // 添加的位置 index 0, // 删除的数量 0 // item to insert ) # 添加元素 itemssplice( 0, // 删除的位置 1, // 删除的数量 ) # 删除元素 # 遍历数组 items.map(d=\u0026gt;d); items.forEach(d=\u0026gt;{ // body }) 数据类型\r#\rlet str = \u0026#39;strings\u0026#39; let num = 123 // number 类型可以是任何数字类型 let bool = false map 映射\r#\rkey - value 关系， key 可以是任何类型\nlet m = new Map([ [ 1 , \u0026#39;number 1\u0026#39; ], [ \u0026#39;1\u0026#39; , \u0026#39;string 1\u0026#39; ] ]) m.get(1) // 获取 key1 的值 m.set(1,1) // 重新赋值 m.clear() // 清空值 set 集合\r#\r不重复的数组\nlet s = new Set([1,2,3]) 控制流\r#\rwhile ( a \u0026lt; 10 ) { a++ } for ( let i = 0; i \u0026lt; 10; i++ ) { console.log(i) } if ( a\u0026gt; b ) { // body } else if ( a === b ){ // body } else { // body } if ( a \u0026gt; b ) alert(\u0026#39;ok\u0026#39;); else alert(\u0026#39;not\u0026#39;) 函数 function\r#\r定义\r#\rfunction funcname (param){ return param } const funname = function (param) { return param } ( function (param) { return param })(\u0026#39;hello world\u0026#39;) let fun = function(params){} //可以缩写成如下 箭头函数会改变this的指向 let fun= params =\u0026gt;{} //当参数有两个及以上时,如下： let fun= (params1,params2,,,)=\u0026gt;{} 高阶函数\r#\rfunction first( a,b,callback){ return callback(a,b) } function second(c,d){ return c + d } first(1,2,second) 闭包\r#\rfunction closurefunc(a,b){ return function(i){ return Math.pow(a+b,i); } } 特殊对象\r#\rJSON 对象的序列化、反序列化操作 JSON.stringify 序列化 JSON.parse 反序列化 Date 时间操作对象 new Date(dateString)\njs进阶\r#\r"},{"id":18,"href":"/docs/program-language/python/data/pandas/","title":"Pandas","section":"Data","content":"\rPANDAS\r#\rimport pandas as pd mydataset = { \u0026#39;sites\u0026#39;: [\u0026#34;Google\u0026#34;, \u0026#34;Runoob\u0026#34;, \u0026#34;Wiki\u0026#34;], \u0026#39;number\u0026#39;: [1, 2, 3] } myvar = pd.DataFrame(mydataset) SERIES\r#\rSeries 类似表格中的一个列（column），类似于一维数组，可以保存任何数据类型。\nSeries 由索引（index）和列组成\npandas.Series( data, index, dtype, name, copy) # data：一组数据(ndarray 类型)。 # index：数据索引标签，如果不指定，默认从 0 开始。 # dtype：数据类型，默认会自己判断。 # name：设置名称。 # copy：拷贝数据，默认为 False。 a = [1, 2, 3] mva = pd.Series(a) # ********** # 索引 数据 # 0 1 # 1 2 # 2 3 # dtype: int64 数据类型 # ********** mva[1] # 2 # 可以指定索引值 a = [\u0026#34;Google\u0026#34;, \u0026#34;Edge\u0026#34;, \u0026#34;Firefox\u0026#34;] mva = pd.Series(a, index = [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;]) # ********** # x Google # y Edge # z Firefox # dtype: object # ********** mva[\u0026#39;x\u0026#39;] # Google # 可以使用 key/value 对象，类似字典来创建 Series mva = {1: \u0026#34;Google\u0026#34;, 2: \u0026#34;Edge\u0026#34;, 3: \u0026#34;Firefox\u0026#34;} mva = pd.Series(mva) # ********** # 1 Google # 2 Edge # 3 Firefox # dtype: object # ********** # 只需要字典中的一部分数据，只需要指定需要数据的索引 mva = {1: \u0026#34;Google\u0026#34;, 2: \u0026#34;Edge\u0026#34;, 3: \u0026#34;Firefox\u0026#34;} mva = pd.Series(mva, index = [1, 2]) # ********** # 1 Google # 2 Edge # dtype: object # ********** # 设置 Series 名称参数 mva = pd.Series(mva, index = [1, 2],name=\u0026#39;NameHere\u0026#39;) DATAFRAME\r#\rDataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）\nDataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）\npandas.DataFrame( data, index, columns, dtype, copy) # data：一组数据(ndarray、series, map, lists, dict 等类型)。 # index：索引值，或者可以称为行标签。 # columns：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。 # dtype：数据类型。 # copy：拷贝数据，默认为 False。 data = [[\u0026#39;Google\u0026#39;,10],[\u0026#39;Edge\u0026#39;,12],[\u0026#39;Firefox\u0026#39;,13]] df = pd.DataFrame(data,columns=[\u0026#39;Site\u0026#39;,\u0026#39;Age\u0026#39;],dtype=float) # ********** # site age # 0 Google 10.0 # 1 Edge 12.0 # 2 Firefox 13.0 # ********** data = {\u0026#39;Site\u0026#39;:[\u0026#39;Google\u0026#39;, \u0026#39;Edge\u0026#39;, \u0026#39;Firefox\u0026#39;], \u0026#39;Age\u0026#39;:[10, 12, 13]} df = pd.DataFrame(data) # ********** # site age # 0 Google 10.0 # 1 Edge 12.0 # 2 Firefox 13.0 # ********** data = [{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2},{\u0026#39;a\u0026#39;: 5, \u0026#39;b\u0026#39;: 10, \u0026#39;c\u0026#39;: 20}] df = pd.DataFrame(data) # 没有对应的部分数据为 NaN。 # ********** # a b c # 0 1 2 NaN # 1 5 10 20.0 # ********** # 可以使用 loc 属性返回指定行的数据，如果没有设置索引，第一行索引为 0，第二行索引为 1 data = { \u0026#34;calories\u0026#34;: [420, 380, 390], \u0026#34;duration\u0026#34;: [50, 40, 45] } df = pd.DataFrame(data) df.loc[0] df.loc[1] # ********** # calories 420 # duration 50 # Name: 0, dtype: int64 # calories 380 # duration 40 # Name: 1, dtype: int64 # ********** # 返回多行数据 df.loc[[0, 1]] # ********** # calories duration # 0 420 50 # 1 380 40 # ********** # 可以指定返回数据索引值 pd.DataFrame(data, index = [\u0026#34;day1\u0026#34;, \u0026#34;day2\u0026#34;, \u0026#34;day3\u0026#34;]) # ********** # calories duration # day1 420 50 # day2 380 40 # day3 390 45 # ********** # 可以使用 loc 属性返回指定索引 对应到某一行 data = { \u0026#34;calories\u0026#34;: [420, 380, 390], \u0026#34;duration\u0026#34;: [50, 40, 45] } df = pd.DataFrame(data, index = [\u0026#34;day1\u0026#34;, \u0026#34;day2\u0026#34;, \u0026#34;day3\u0026#34;]) df.loc[\u0026#34;day2\u0026#34;] # ********** # calories 380 # duration 40 # Name: day2, dtype: int64 # ********** # 获取 dataframe 中其中几列 data = { \u0026#34;mango\u0026#34;: [420, 380, 390], \u0026#34;apple\u0026#34;: [50, 40, 45], \u0026#34;pear\u0026#34;: [1, 2, 3], \u0026#34;banana\u0026#34;: [23, 45,56] } df = pd.DataFrame(data) df[[\u0026#34;apple\u0026#34;,\u0026#34;banana\u0026#34;]] CSV\r#\rJSON\r#\r数据清洗\r#\rFUNCTIONS\r#\r"},{"id":19,"href":"/docs/program-language/python/database/","title":"Database","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":20,"href":"/docs/program-language/python/database/mongodb/","title":"MongoDB","section":"Database","content":"\rMongoDB\r#\rimport pymango MongoDB ✈\nWORKFLOW\r#\rmyclient = pymongo.MongoClient(\u0026#39;mongodb://localhost:27017/\u0026#39;) db = mongo_client.admin db.authenticate(\u0026#39;用户名\u0026#39;, \u0026#39;密码\u0026#39;) # 创建集合 db.createCollection(name, options) # 删除集合 db.collectionName.drop() # 指定数据库和集合 db = client.test # 获取数据库 db = client[\u0026#39;test\u0026#39;] collection = db.stu # 指定集合 collection = db[\u0026#39;stu\u0026#39;] 插入\r#\rdb.collection_name.insert(document) # mongodb中文档的格式是json格式 #增加一条 stu1={\u0026#39;id\u0026#39;:\u0026#39;001\u0026#39;,\u0026#39;name\u0026#39;:\u0026#39;zhangsan\u0026#39;,\u0026#39;age\u0026#39;:10} result = collection.insert_one(stu1) #增加多条 stu2={\u0026#39;id\u0026#39;:\u0026#39;002\u0026#39;,\u0026#39;name\u0026#39;:\u0026#39;lisi\u0026#39;,\u0026#39;age\u0026#39;:15} stu3={\u0026#39;id\u0026#39;:\u0026#39;003\u0026#39;,\u0026#39;name\u0026#39;:\u0026#39;wangwu\u0026#39;,\u0026#39;age\u0026#39;:20} result = collection.insert_many([stu2,stu3]) 删除\r#\r#可以直接使用remove方法删除指定的数据 result = collection.remove({\u0026#39;name\u0026#39;: \u0026#39;zhangsan\u0026#39;}) #使用delete_one()删除一条数据 result = collection.delete_one({\u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;}) #delete_many()删除多条数据 result = collection.delete_many({\u0026#34;age\u0026#34;:{\u0026#39;$lt\u0026#39;:20}}) 修改\r#\r#update_one,第 2 个参数需要使用$类型操作符作为字典的键名 #姓名为zhangsan的记录，age修改为22 condition = {\u0026#39;name\u0026#39;: \u0026#39;zhangsan\u0026#39;} res = collection.find_one(condition) res[\u0026#39;age\u0026#39;] = 22 result = collection.update_one(condition, {\u0026#39;$set\u0026#39;: res}) print(result) #返回结果是UpdateResult类型 print(result.matched_count,result.modified_count) #获得匹配的数据条数1、影响的数据条数1 #update_many,所有年龄为15的name修改为xixi condition = {\u0026#39;age\u0026#39;: 15} res = collection.find_one(condition) res[\u0026#39;age\u0026#39;] = 30 result = collection.update_many(condition, {\u0026#39;$set\u0026#39;:{\u0026#39;name\u0026#39;:\u0026#39;xixi\u0026#39;}}) print(result) #返回结果是UpdateResult类型 print(result.matched_count,result.modified_count) #获得匹配的数据条数3、影响的数据条数3 查找\r#\r# 返回所有满足条件的结果，如果条件为空，则返回全部结果，返回结果是一个Cursor游标可迭代对象。 rets = collection.find({\u0026#34;age\u0026#34;:20}) for ret in rets: print(ret) # 查询结果有多少条数据 count = collection.find().count() # 查询结果按年龄升序排序 results = collection.find().sort(\u0026#39;age\u0026#39;, pymongo.ASCENDING) print([result[\u0026#39;age\u0026#39;] for result in results]) "},{"id":21,"href":"/docs/program-language/python/database/redis/","title":"Redis","section":"Database","content":"\rREDIS\r#\rimport redis WORKFLOW\r#\rredis_conn = redis.Redis(host=\u0026#34;192.168.31.196\u0026#34;, port=6379,password=\u0026#34;123456\u0026#34;) # 连接池 redis_pool = redis.ConnectionPool(host=\u0026#39;127.0.0.1\u0026#39;, port= 6379, password= \u0026#39;your pw\u0026#39;, db= 0) redis_conn = redis.Redis(connection_pool= redis_pool) redis_conn.set(\u0026#39;name1\u0026#39;, \u0026#39;value1) #添加 redis_conn.get(\u0026#39;name1\u0026#39;) #获取 STRING 字符串\r#\r一个键对应一个值\n# 设置单个键值 set(name, value[, ex=None, px=None, nx=False, xx=False]) # ex：过期时间（秒），时间到了后redis会自动删除 # px：过期时间（毫秒），时间到了后redis会自动删除。ex、px二选一即可 # nx：如果设置为True，则只有name不存在时，当前set操作才执行 # xx：如果设置为True，则只有name存在时，当前set操作才执行 redis_conn.set(\u0026#39;name_2\u0026#39;, \u0026#39;ZZZ_2\u0026#39;) # 获取单个值 redis_conn.get(\u0026#39;name_1\u0026#39;) # 设置多个键值 mset(*args, **kwargs) redis_conn.mset(name_1= \u0026#39;ZZZ1\u0026#39;, name_2= \u0026#39;ZZZ2\u0026#39;) name_dict = { \u0026#39;name_4\u0026#39; : \u0026#39;ZZZ4\u0026#39;, \u0026#39;name_5\u0026#39; : \u0026#39;ZZZ5\u0026#39; } redis_conn.mset(name_dict) # 获取多个值 mget(keys, *args) m = redis_conn.mget(\u0026#39;name_1\u0026#39;, \u0026#39;name_2\u0026#39;) #m = redis_conn.mget([\u0026#39;name_1\u0026#39;, \u0026#39;name_2\u0026#39;]) 也行 # 给已有的键设置新值，并返回原有的值 getset(name, value) v = redis_conn.getset(\u0026#39;name_1\u0026#39;, \u0026#39;hi\u0026#39;) # 所给的键不存在时，会设置其新值，但返回值为None # String setrange 根据索引修改某个键的value值 setrange(name, offset, value) # 返回值为：修改后的字符串长度 # name：键，所给不存在时自动添加 # offset：偏移量，以0开始，全部修改 # value：修改的字符或字符串，字符串时以offset向后顺延 length = redis_conn.setrange(\u0026#39;name_2\u0026#39;, 1, \u0026#39;zhihu\u0026#39;) # String getrange 根据索引获取某个键的部分value值 getrange(key, start, end) # 若所给的键不存在时，返回空值 b\u0026#39;\u0026#39; v = redis_conn.getrange(\u0026#39;name_4\u0026#39;, 0, 2) # 返回前3个字符 # String strlen 获取value的长度 strlen(name) # 所给的键不存在时，返回值为0 length = redis_conn.strlen(\u0026#39;name_2\u0026#39;) # String incr int类型的value自增（自减 decr(name, amount=1) incr(name, amount=1) # 值必须是整数或字符串的数值，不然会报错。默认自增幅度为1 redis_conn.set(\u0026#39;num_2\u0026#39;, 2) # redis_conn.set(\u0026#39;num_2\u0026#39;, \u0026#39;2\u0026#39;) 都行 v = redis_conn.incr(\u0026#39;num_2\u0026#39;) # 返回值：修改后的值，int类型 # String incrbyfloat 浮点数类型的value自增 incrbyfloat(name, amount=1.0) v = redis_conn.incrbyfloat(\u0026#39;num_2\u0026#39;) # 返回值：浮点数类型float # String append value后面追加 append(key, value) # 若所给的键不存在，则设置新值 length = redis_conn.append(\u0026#39;name_5\u0026#39;, \u0026#39;666\u0026#39;) # 返回值为修改后的字符串的长度 LIST 列表\r#\r一个键对应一个列表\n# List lpush 列表左边添加值 rpush（右边） lpush(name, *values) # value值有多个时，从左到右依次向列表左边添加，类型可以不同 # 所给的键不存在时，新建一个列表 # 返回值：列表的大小 v = redis_conn.lpush(\u0026#39;Zarten\u0026#39;, 1,2,3,4,5) # List lpushx 键存在时，添加到列表左边 rpushx（最右边） lpushx(name, value) # 只有键存在时，才添加。若键不存在则不添加，也不新创建列表 v = redis_conn.lpushx(\u0026#39;Zarten_1\u0026#39;, \u0026#39;hehe\u0026#39;) # 返回值为：列表大小 # List llen 获取所给键的列表大小 llen(name) v = redis_conn.llen(\u0026#39;Zarten\u0026#39;) # List linsert 在列表中间插入新值 linsert(name, where, refvalue, value) # 返回：插入后列表的长度，若返回-1，则refvalue不存在 # name：键名 # where：位置，前面（BEFORE）或后面（AFTER） # refvalue：指定哪个值的前后插入 # value：插入的新值 v = redis_conn.linsert(\u0026#39;Zarten\u0026#39;, \u0026#39;AFTER\u0026#39;, 6, \u0026#39;b\u0026#39;) # 值 6 的后面插入 \u0026#39;b\u0026#39; # List lset 列表中通过索引赋值 lset(name, index, value) # 返回值：成功 True 否则 False v = redis_conn.lset(\u0026#39;Zarten\u0026#39;, 2, \u0026#39;cc\u0026#39;) # List lindex 通过索引获取列表值 lindex(name, index) v = redis_conn.lindex(\u0026#39;Zarten\u0026#39;, 2) # List lrange 列表中获取一段数据 lrange(name, start, end) # 返回值：List类型的一段数据 v = redis_conn.lrange(\u0026#39;Zarten\u0026#39;, 2, 5) # List lpop 删除左边的第一个值 rpop（右边） lpop(name) # 返回值：被删除元素的值 v = redis_conn.rpop(\u0026#39;Zarten\u0026#39;) # List lrem 删除列表中N个相同的值 lrem(name, value, num=0) # 返回删除的个数 # name：键名 # value：需删除的值 # num：删除的个数 整数表示从左往右 负数表示从右往左 例如：2 -2 v = redis_conn.lrem(\u0026#39;Zarten\u0026#39;, \u0026#39;hehe\u0026#39;, -2) # List ltrim 删除列表中范围之外的所有值 ltrim(name, start, end) # 返回：成功 True v = redis_conn.ltrim(\u0026#39;Zarten\u0026#39;, 5, 10) # List blpop 删除并返回列表最左边的值 brpop（最右边） blpop(keys, timeout=0) # 返回值：tuple类型 形如： (键名, 删除的值) (b\u0026#39;Zarten\u0026#39;, b\u0026#39;hehe\u0026#39;) # keys：给定的键 # timeout：等待超时时间，默认为0，表示一直等待 v = redis_conn.blpop(\u0026#39;Zarten\u0026#39;) # List rpoplpush 一个列表中最右边值取出后添加到另一个列表的最左边 brpoplpush阻塞版本 rpoplpush(src, dst) # 返回值：取出的元素值 # brpoplpush(src, dst, timeout=0)为rpoplpush的阻塞版本，timeout为0时，永远阻塞 v = redis_conn.rpoplpush(\u0026#39;Zarten\u0026#39;, \u0026#39;Zhihu\u0026#39;) HASH 哈希\r#\r内部存储为各个键值对\n# Hash hset 哈希中添加一个键值对 hset(name, key, value) # 返回添加成功的个数 int # key存在，则修改，否则添加 v = redis_conn.hset(\u0026#39;Zarten\u0026#39;, \u0026#39;age\u0026#39;, 10) # Hash hmset 设置哈希中的多个键值对 hmset(name, mapping) # 返回值：成功 True # mapping：dict 类型 v = redis_conn.hmset(\u0026#39;Zarten\u0026#39;, {\u0026#39;sex\u0026#39;:1, \u0026#39;tel\u0026#39;:\u0026#39;123\u0026#39;}) # Hash hmget 获取哈希中多个键值对 hmget(name, keys, *args) # 返回值：值的列表 list 形如： [b\u0026#39;1\u0026#39;, b\u0026#39;123\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; v = redis_conn.hmget(\u0026#39;Zarten\u0026#39;, [\u0026#39;sex\u0026#39;, \u0026#39;tel\u0026#39;]) #v = redis_conn.hmget(\u0026#39;Zarten\u0026#39;, \u0026#39;sex\u0026#39;, \u0026#39;tel\u0026#39;) 也ok # Hash hget 获取指定key的值 hget(name, key) v = redis_conn.hget(\u0026#39;Zarten\u0026#39;, \u0026#39;age\u0026#39;) # Hash hgetall 获取哈希中所有的键值对 hgetall(name) # 返回值：dict类型 v = redis_conn.hgetall(\u0026#39;Zarten\u0026#39;) # Hash hlen 获取哈希中键值对的个数 hlen(name) v = redis_conn.hlen(\u0026#39;Zarten\u0026#39;) # Hash hkeys 获取哈希中所有的键key hkeys(name) # 返回值：list类型 v = redis_conn.hkeys(\u0026#39;Zarten\u0026#39;) # Hash hvals 获取哈希中所有的值value hvals(name) # 返回值：list类型 v = redis_conn.hvals(\u0026#39;Zarten\u0026#39;) # Hash hexists 检查哈希中是否有某个键key hexists(name, key) # 返回值：有 True ；否则 False v = redis_conn.hexists(\u0026#39;Zarten\u0026#39;, \u0026#39;b\u0026#39;) # Hash hdel 删除哈希中键值对（key-value） hdel(self, name, *keys) # 返回值：int 删除的个数 v = redis_conn.hdel(\u0026#39;Zarten\u0026#39;, \u0026#39;age\u0026#39;) # Hash hincrby 自增哈希中key对应的value值（必须整数数值类型） hincrby(name, key, amount=1) # 返回int 增加后的数值 # 若所给的key不存在则创建，amount默认增加1，可以为负数 v = redis_conn.hincrby(\u0026#39;Zarten\u0026#39;, \u0026#39;sex\u0026#39;, -3) # Hash hincrbyfloat 自增浮点数 同上hincrby hincrbyfloat(name, key, amount=1.0) # Hash expire 设置整个键的过期时间 expire(name, time) # time：秒，时间一到，立马自动删除 v = redis_conn.expire(\u0026#39;Zarten\u0026#39;, 10) # Hash hscan 增量迭代获取哈希中的数据 hscan(name, cursor=0, match=None, count=None) # 返回值：tuple 类型 ；（扫描位置，所有dict数据） # name：redis的name # cursor：游标（基于游标分批取获取数据） # match：匹配指定key，默认None 表示所有的key # count：每次分片最少获取个数，默认None表示采用Redis的默认分片个数 v = redis_conn.hscan(\u0026#39;Zarten\u0026#39;) # Hash hscan_iter 返回hscan的生成器 hscan_iter(name, match=None, count=None) v = redis_conn.hscan_iter(\u0026#39;Zarten\u0026#39;) for i in v: print(type(i), i) SET 集合\r#\r集合中的元素不重复，一般用于过滤元素\n# Set sadd 添加元素到集合中 sadd(name, *values) # 若插入已有的元素，则自动不插入 v = redis_conn.sadd(\u0026#39;Zarten\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) # Set scard 返回集合中元素的个数 scard(name) v = redis_conn.scard(\u0026#39;Zarten\u0026#39;) # Set smembers 获取集合中的所有元素 smembers(name) # 返回值：set类型，形如： {b\u0026#39;a\u0026#39;, b\u0026#39;apple\u0026#39;, b\u0026#39;c\u0026#39;, b\u0026#39;b\u0026#39;} v = redis_conn.smembers(\u0026#39;Zarten\u0026#39;) # Set srandmember 随机获取一个或N个元素 srandmember(name, number=None) # 返回值：返回一个值或一个列表 # name：键名 # number：一个或N个，默认返回一个。若返回N个，则返回List类型 v = redis_conn.srandmember(\u0026#39;Zarten\u0026#39;, 2) # Set sismember 判断某个值是否在集合中 sismember(name, value) # 返回值：True 在 False 不在 v = redis_conn.sismember(\u0026#39;Zarten\u0026#39;, \u0026#39;appl\u0026#39;) # Set spop 随机删除并返回集合中的元素 spop(name) v = redis_conn.spop(\u0026#39;Zarten\u0026#39;) # Set srem 删除集合中的一个或多个元素 srem(name, *values) # 返回值：返回删除的个数 int v = redis_conn.srem(\u0026#39;Zarten\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;) # Set smove 将一个集合中的值移动到另一个集合中 smove(src, dst, value) # 返回值：成功 True # 若value不存在时，返回False v = redis_conn.smove(\u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;, \u0026#39;apple\u0026#39;) # Set sdiff 返回在一个集合中但不在其他集合的所有元素（差集） sdiff(keys, *args) # 返回值：set类型 {b\u0026#39;2\u0026#39;, b\u0026#39;4\u0026#39;, b\u0026#39;3\u0026#39;, b\u0026#39;1\u0026#39;} # 在keys集合中，不在其他集合中的元素 v = redis_conn.sdiff(\u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;) # Set sdiffstore 上面的sdiff的返回值（差集）保存在另一个集合中 sdiffstore(dest, keys, *args) # 返回值：int 返回作用的个数 # 在keys集合中，不在其他集合中的元素保存在dest集合中 # dest：新的集合，设置的新集合，旧集合会被覆盖 v = redis_conn.sdiffstore(\u0026#39;Left\u0026#39;, \u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;) # Set sinter 返回一个集合与其他集合的交集 sinter(keys, *args) # 返回值：set类型 v = redis_conn.sinter(\u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;) # Set sinterstore 返回一个集合与其他集合的交集，并保存在另一个集合中 sinterstore(dest, keys, *args) # dest：另一个集合，设置新集合，旧集合元素会被覆盖 v = redis_conn.sinterstore(\u0026#39;Left\u0026#39;, \u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;) # Set sunion 返回一个集合与其他集合的并集 sunion(keys, *args) v = redis_conn.sunion(\u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;) # Set sunionstore 返回一个集合与其他集合的并集，并保存在另一个集合中 sunionstore(dest, keys, *args) # 返回新集合元素个数 # dest：另一个集合，设置新集合，旧集合元素会被覆盖 v = redis_conn.sunionstore(\u0026#39;Left\u0026#39;, \u0026#39;Zarten\u0026#39;, \u0026#39;Fruit\u0026#39;) ZSET 有序集合\r#\r有序集合比集合多了一个分数的字段，可对分数升序降序\n# Zset zadd 有序集合中添加元素 zadd(name, *args, **kwargs) # 返回添加的个数 # 添加元素时需指定元素的分数 v = redis_conn.zadd(\u0026#39;Zarten\u0026#39;, \u0026#39;a\u0026#39;, 3, \u0026#39;b\u0026#39;, 4) #v = redis_conn.zadd(\u0026#39;Zarten\u0026#39;, c= 5, d= 6) # Zset zcard 返回有序集合中元素个数 zcard(name) v = redis_conn.zcard(\u0026#39;Zarten\u0026#39;) # Zset zcount 返回有序集合中分数范围内的元素个数 zcount(name, min, max) # 返回个数 int # 包含min max v = redis_conn.zcount(\u0026#39;Zarten\u0026#39;, 3, 5) # Zset zscore 返回有序集合中指定某个值的分数 zscore(name, value) # 返回值：float 类型的分数；形如： -5.0 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; v = redis_conn.zscore(\u0026#39;Zarten\u0026#39;, \u0026#39;zhi\u0026#39;) # Zset zincrby 增加有序集合中某个值的分数 zincrby(name, value, amount=1) # 返回增加后的分数 float类型 ；形如： -5.0 \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; # value：若存在，则增加其amount分数；若不存在，则增加新值以及对应的分数 # amount：增加的值，可以为负数 v = redis_conn.zincrby(\u0026#39;Zarten\u0026#39;, \u0026#39;zhi\u0026#39;, -5) # Zset zrem 删除有序集合中的某个或多个值 zrem(name, *values) # 返回删除的个数 v = redis_conn.zrem(\u0026#39;Zarten\u0026#39;, \u0026#39;zhi\u0026#39;, \u0026#39;a\u0026#39;) # Zset zremrangebyrank 删除有序集合元素根据排序范围 zremrangebyrank(name, min, max) # 返回删除个数 int v = redis_conn.zremrangebyrank(\u0026#39;Zarten\u0026#39;, 1, 3) # Zset zremrangebyscore 删除有序集合根据分数范围 zremrangebyscore(name, min, max) # 返回删除个数 int v = redis_conn.zremrangebyscore(\u0026#39;Zarten\u0026#39;, 8, 15) # Zset zrank 返回某个值在有序集合中的分数排名（从小到大） zrevrank（从大到小） zrank(name, value) # 返回value在name中的分数排名值，分数从小到大排名，从0开始 v = redis_conn.zrank(\u0026#39;Zarten\u0026#39;, \u0026#39;b\u0026#39;) # Zset zrange 返回有序集合分数排序的一段数据 zrange(name, start, end, desc=False, withscores=False, score_cast_func=float) # 返回list类型 [(b\u0026#39;tt\u0026#39;, 10.0), (b\u0026#39;d\u0026#39;, 6.0), (b\u0026#39;c\u0026#39;, 5.0)] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; # name：redis的name # start：有序集合索引起始位置（非分数） # end：有序集合索引结束位置（非分数） # desc：排序规则，默认按照分数从小到大排序 # withscores：是否获取元素的分数，默认只获取元素的值 # score_cast_func：对分数进行数据转换的函数 v = redis_conn.zrange(\u0026#39;Zarten\u0026#39;, 1, 3, True, True, score_cast_func=float) BITMAP 位图\r#\rbitmap中存放二进制的位0和1，类似位数组。典型应用是基于redis的布隆过滤器。\n属于String字符串数据结构，固bit 映射被限制在 512 MB 之内（2^32）\n# Bitmap setbit 设置位图的值 setbit(name, offset, value) # name：redis键名 # offset：偏移量，大于等于0。当偏移伸展时，空白位置以0填充 # value：二进制值 0或1 v = redis_conn.setbit(\u0026#39;Zarten_2\u0026#39;, 100, 1) # Bitmap getbit 返回位图指定偏移量的值 getbit(name, offset) # 返回0或1 v = redis_conn.getbit(\u0026#39;Zarten_2\u0026#39;, 101) # Bitmap bitcount 返回位图中二进制为1的总个数 bitcount(key, start=None, end=None) # start end指定开始和结束的位，默认整个位图 v = redis_conn.bitcount(\u0026#39;Zarten_2\u0026#39;, 100, 1000) "},{"id":22,"href":"/docs/program-language/python/database/sql/","title":"Sql","section":"Database","content":"\rSQL\r#\rimport pymysql WORKFLOW\r#\r# 连接数据库 db = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port = 3306, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;, database=\u0026#39;DB\u0026#39;, charset=\u0026#39;utf8mb4\u0026#39;) # 建立游标 cur = db.cursor() # 使用 execute() 方法执行 SQL，如果表存在则删除 cursor.execute(\u0026#34;DROP TABLE IF EXISTS EMPLOYEE\u0026#34;) # 执行sql语句 sql = \u0026#34;DELETE FROM STUDENT WHERE NAME=\u0026#39;ZZZ\u0026#39;\u0026#34; cursor.execute(sql) # 提交修改 db.commit() # 关闭数据库连接 db.close() 插入\r#\rsql = \u0026#34;INSERT INTO STUDENT(NAME,AGE, SEX, ID) VALUES (\u0026#39;ZZZ\u0026#39;, 22, 女,1)\u0026#34; #try语句防止连接数据库时发生错误 try: cursor.execute(sql) db.commit() print(\u0026#34;数据插入成功\u0026#34;) except: # 如果发生错误则回滚 db.rollback() 查询\r#\rsql = \u0026#34;SELECT * FROM STUDENT WHERE NAME=\u0026#39;ZZZ\u0026#39;\u0026#34; try: cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() # result = cursor.fetchone() 获取单条数据 for row in results:#遍历查询结果 name = row[0] age = row[1] sex = row[2] id = row[3] print (\u0026#34;name:%s,age:%d,sex:%s,id:%s\u0026#34; % (name,age,sex,id)) except: print (\u0026#34;查询失败\u0026#34;) 更新\r#\rsql = \u0026#34;UPDATE STUDENT SET AGE = 20 WHERE SEX = \u0026#39;%s\u0026#39;\u0026#34; % (\u0026#39;女\u0026#39;) try: cursor.execute(sql) db.commit() print(\u0026#34;数据更新成功\u0026#34;) except: db.rollback() print(\u0026#34;数据更新失败\u0026#34;) 删除\r#\rsql = \u0026#34;DELETE FROM STUDENT WHERE NAME=\u0026#39;ZZZ\u0026#34; try: cursor.execute(sql) db.commit() print(\u0026#34;数据删除成功\u0026#34;) except: db.rollback() print(\u0026#34;数据删除失败\u0026#34;) 新建表\r#\rsql = \u0026#34;\u0026#34;\u0026#34;CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )\u0026#34;\u0026#34;\u0026#34; cursor.execute(sql) "},{"id":23,"href":"/docs/program-language/python/ui/","title":"Ui","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":24,"href":"/docs/program-language/python/ui/pyside6/","title":"Pyside6","section":"Ui","content":"\rPYSIDE6\r#\rfrom PySide6.QtWidgets import QApplication, QMainWindow class MyWindow(QMainWindow): def __init__(self): super().__init__() # 继承父类的初始化方法 if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication([]) window = MyWindow() window.show() app.exec() 控件\r#\rfrom PySide6.QtWidgets import QApplication, QMainWindow,QPushButton,QLabel,QLineEdit class MyWindow(QMainWindow): def __init__(self): super().__init__() # 继承父类的初始化方法 # 按钮 btn = QPushButton(\u0026#39;Click\u0026#39;,self) btn.setGeometry(100,100,200,100) # 设置集合 x坐标 y坐标 w宽度 h高度 btn.setToolTip(\u0026#39;离我远点\u0026#39;) # 鼠标防止在按钮上 显示的提示内容 类似于hover btn.setText(\u0026#39;btn text\u0026#39;) # 按钮显示文字设置 # 标签 label lb = QLabel(\u0026#39;I am a label\u0026#39;,self) lb.setAlignment(Qt.AlignmentFlag.AlignCenter) # 居中 # 文本输入 line = QLineEdit(\u0026#39;\u0026#39;,self) line.setPlaceholderText(\u0026#39;type here\u0026#39;) # 文本提示 placeholder # ComboBox 单选 cb = QComboBox(self) cb.addItems([\u0026#39;独一无二\u0026#39;,\u0026#39;唯快不破\u0026#39;,\u0026#39;沧海笑\u0026#39;]) cb.currentIndexChanged.connect(lambda:print(cb.currentText())) # cb.currentText() 获取cb当前选中的文本 # checkbox ck = QCheckBox(\u0026#39;check?\u0026#39;,self) ck.stateChanged.connect(self.showState) # 会传入一个状态进去 ck.inChecked() # true or false 检查当前是否被选中 def showState(self,state): print(state) 信号与槽\r#\r# 按钮 btn = QPushButton(\u0026#39;Click\u0026#39;,self) btn.clicked.connect(self.hello) # 点击按钮执行 hello 函数 # Simple Login View from PySide6.QtWidgets import QApplication, QWidget,QPushButton,QLabel,QLineEdit from PySide6.QtCore import Qt from Ui_login_from import Ui_Dialog # 导入 qt设计师 class MyWindow(QWidget,Ui_Dialog): # 继承 qt设计师 模块 def __init__(self): super().__init__() self.setupUi(self) # 导入 qt设计师 的界面 self.pushButton.clicked.connect(self.loginFuc) # 点击事件 def loginFuc(self): account = self.lineEdit.text() password = self.lineEdit_2.text() # 获取指定控件 lineEdit_2 的文本 if account == \u0026#39;123\u0026#39; and password == \u0026#39;123\u0026#39;: print(\u0026#39;succ\u0026#39;) else: print(\u0026#39;faild\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication([]) window = MyWindow() window.show() app.exec() # Simple Cacu from PySide6.QtWidgets import QApplication, QWidget from Ui_cacu import Ui_Form class MyWindow(QWidget,Ui_Form): def __init__(self): super().__init__() # 继承父类的初始化方法 self.setupUi(self) self.result = \u0026#39;\u0026#39; def bind(self): self.pushButton_0.clicked.connect(lambda:self.addNumber(\u0026#39;0\u0026#39;)) # ... self.pushButton_deng.clicked.connect(self.cacul) # 控件点击事件 def cacul(self): self.r = eval(self.result) # 计算字符串的表达式 eval() self.lineEdit.setText(str(self.r)) # 给控件赋值文本 def addNumber(self,n): self.lineEdit.clear() # 清除控件文本 self.result += n self.lineEdit.setText(self.result) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication([]) window = MyWindow() window.show() app.exec() "},{"id":25,"href":"/docs/program-language/python/system/","title":"System","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":26,"href":"/docs/program-language/python/system/pywin32/","title":"Pywin32","section":"System","content":"\rPYWIN32\r#\rimport win32api, win32api win32api.MessageBox(None,\u0026#34;Hello,pywin32!\u0026#34;,\u0026#34;pywin32\u0026#34;,win32con.MB_OK) "},{"id":27,"href":"/docs/program-language/python/basic/basic/","title":"Basic","section":"Basic","content":"\rBASIC\r#\rREQUIREMENTS.txt\r#\rpip freeze \u0026gt; requirements.txt pip install -r requirements.txt STRING\r#\rs = \u0026#39;abcde\u0026#39; 切片\r#\rs[start:stop] # 裁剪 字符串 起止位置， 不包括止 # 负数从后往前数 s[1,3] # bc s[::-1] #edcba 反转字符串 Method\r#\rs.strip() # 删除开头和结尾的空白字符 s.lstrip() # 删除开头空白字符 s.rstrip() # 删除结尾空白字符 s.split(\u0026#34;,\u0026#34;) # 找到分隔符的实例时将字符串拆分为子字符串 s.replace(repl,s [,count]) # 替换原字符串的特定字符 count 替换次数 默认全部 \u0026#39;a\u0026#39; in s # true e not in s # true l = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] \u0026#39; \u0026#39;.join(l) # a b c d # 组合多列表 for x,y in zip(list1,list2): print(x,y) List\r#\rl = [a, b, c, d, e] l.extend(list) # 追加列表到列表中 l.pop([index]) # 弹出最后一个元素 可以指定index值弹出 l.remove(\u0026#39;a\u0026#39;) # 指定删除的内容 del l # 删除列表 l[o] = value # 赋值 l.count(\u0026#39;a\u0026#39;) # 出现的次数 l.index(\u0026#39;a) # 最小索引值 Dict\r#\rdict[\u0026#34;key\u0026#34;] # 获取 key 的值 for x in thisdict.values():print(x) # 循环全部 value 的值 dict[\u0026#34;newkey\u0026#34;] = \u0026#34;value\u0026#34; # 创建新键值对 dict.pop(\u0026#34;key\u0026#34;) # 删除指定key的键值对 del dict[\u0026#34;key\u0026#34;] # 删除指定key的键值对 dict.popitem() # 删除最后插入的项目 "},{"id":28,"href":"/docs/program-language/python/basic/function/","title":"Function","section":"Basic","content":"\rFUNCTION\r#\rLambda\r#\rlambda [arg1 [,arg2,..]]:expression # [arg…] 是参数列表，它的结构与 Python 中函数(function)的参数列表是一样的。 ## [arg…] 可以有非常多的形式。 a, b a=1, b=2 *args **kwargs a, b=1 *args None ... # expression 是一个参数表达式 # 表达式中出现的参数需要在[arg......]中有定义，并且表达式只能是单行的，只能有一个表达式。 1 None a + b sum(a) 1 if a \u0026gt;10 else 0 ... lambda x, y: x*y # 函数输入是x和y，输出是它们的积x*y lambda:None # 函数没有输入参数，输出是None lambda *args: sum(args) # 输入是任意个数参数，输出是它们的和(隐性要求输入参数必须能进行算术运算) lambda **kwargs: 1 # 输入是任意键值对参数，输出是1 lambda 函数是匿名的, 有输入和输出, 拥有自己的命名空间\n不能访问自己参数列表之外或全局命名空间里的参数，只能完成非常简单的功能\n# 将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数 add = lambda x, y: x+y add(1, 2) # 3 # 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换 time.sleep=lambda x: None time.sleep(3) # None map()\r#\rmap(function, iterable, ...) # 返回 迭代器 # 会根据提供的函数对指定序列做映射 function ----\u0026gt; 函数 iterable ----\u0026gt; 一个或多个序列 def square(x):return x ** 2 map(square, [1,2,3,4,5]) # [1, 4, 9, 16, 25] map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # [1, 4, 9, 16, 25] map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) # [3, 7, 11, 15, 19] reduce()\r#\rreduce(function, iterable[, initializer]) # 函数会对参数序列中元素进行累积 function ----\u0026gt; 函数有两个参数 iterable ----\u0026gt; 可迭代对象 initializer ----\u0026gt; 可选 # 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作： ## 用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作， ## 得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 def add(x, y): return x + y reduce(add, [1, 3, 5, 7, 9]) # 列表和 25 reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]) sorted()\r#\rsorted(iterable[, cmp[, key[, reverse]]]) # 返回重新排序的列表 # 函数对所有可迭代的对象进行排序操作 iterable ----\u0026gt; 可迭代对象 cmp ----\u0026gt; 比较的函数, 这个具有两个参数, 参数的值都是从可迭代对象中取出, 此函数必须遵守的规则为，大于则返回1，小于则返回-1. 等于则返回0 key ----\u0026gt; 主要是用来进行比较的元素, 只有一个参数, 具体的函数的参数就是取自于可迭代对象中, 指定可迭代对象中的一个元素来进行排序 reverse ----\u0026gt; 排序规则, reverse = True 降序 , reverse = False 升序(默认) a = [5,7,6,3,4,1,2] b = sorted(a) # [1, 2, 3, 4, 5, 6, 7] 使用sorted，保留原列表，不改变列表a的值 L=[(\u0026#39;b\u0026#39;,2),(\u0026#39;a\u0026#39;,1),(\u0026#39;c\u0026#39;,3),(\u0026#39;d\u0026#39;,4)] sorted(L, cmp=lambda x,y:cmp(x[1],y[1])) # 利用参数 cmp 排序 [(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3), (\u0026#39;d\u0026#39;, 4)] sorted(L, key=lambda x:x[1]) # 利用参数 key 排序 [(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3), (\u0026#39;d\u0026#39;, 4)] filter()\r#\rfilter(function, iterable) # 返回 迭代器对象 # 过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表 function ----\u0026gt; 判断函数 iterable ----\u0026gt; 可迭代对象 # 接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中 def is_odd(n): return n % 2 == 1 newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) # [1, 3, 5, 7, 9] newlist = filter(lambda x: x % 3 == 0, [1, 2, 3]) list(newlist) # 3 装饰器Decorator\r#\r闭包\r#\rdef outer(x): def inner(y): return x + y return inner outer(6)(5) # 11 # outer(6)(5) 第一个参数传给自身函数 outer， 得到返回值 inner # 在把 第二个参数传给 inner(y) 装饰器\r#\r拓展原来函数功能的函数，返回值也是一个函数\ndef who(func): def run(): print(\u0026#39;who is running\u0026#39;) func() # running() return run @who def running(): print(\u0026#39;out func running\u0026#39;) func() # who is running # out func running 把函数当作参数传入装饰器里面， 在装饰器里面特定位置进行调用函数\n带参数装饰器\r#\rdef who(msg=None): def count(func) def run(*args,**kwargs): print(\u0026#39;who is running\u0026#39;) func(*args,**kwargs) # running() print(\u0026#39;xiao\u0026#39;) return run return count @who(msg=\u0026#39;xiao\u0026#39;) def where(func): print(\u0026#39;where\u0026#39;) func() print(\u0026#39;you?\u0026#39;) def running(): print(\u0026#39;out func running\u0026#39;) where(running) # who is running # where # out func running # you? # xiao 类装饰器\r#\rclass deco: def __init__(self,func): self.func = func print(\u0026#34;class init function\u0026#34;) def __call__(self,*args,**kwargs): print(\u0026#39;class call function\u0026#39;) self.func(*args,**kwargs) print(\u0026#39;class end\u0026#39;) @deco def chocolate(): print(\u0026#39;eat chocolate\u0026#39;) @deco def market(): print(\u0026#39;run and buy fruit\u0026#39;) chcoclate() market() # class init function # class call function # eat chocolate # class end 带参数类装饰器\r#\rclass Decorator: def __init__(self, arg1, arg2): # init()方法里面的参数都是装饰器的参数 print(\u0026#39;执行类Decorator的__init__()方法\u0026#39;) self.arg1 = arg1 self.ag2 = arg2 def __call__(self, func): # 因为装饰器带了参数，所以接收传入函数变量的位置是这里 print(\u0026#39;执行类Decorator的__call__()方法\u0026#39;) def b_warp(*args): # 这里装饰器的函数名字可以随便命名，只要跟return的函数名相同即可 print(\u0026#39;执行wrap()\u0026#39;) print(\u0026#39;装饰器参数：\u0026#39;, self.arg1, self.arg2) print(\u0026#39;执行\u0026#39; + func.__name__ + \u0026#39;()\u0026#39;) func(*args) print(func.__name__ + \u0026#39;()执行完毕\u0026#39;) return b_warp @Decorator(\u0026#39;Hello\u0026#39;, \u0026#39;Xiao\u0026#39;) def example(a1, a2, a3): print(\u0026#39;传入example()的参数：\u0026#39;, a1, a2, a3) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;准备调用example()\u0026#39;) example(\u0026#39;Baiyu\u0026#39;, \u0026#39;Happy\u0026#39;, \u0026#39;Coder\u0026#39;) 装饰器顺序\r#\rdef Decorator_1(func): def wrapper(*args, **kwargs): func(*args, **kwargs) print(\u0026#39;我是装饰器1\u0026#39;) return wrapper def Decorator_2(func): def wrapper(*args, **kwargs): func(*args, **kwargs) print(\u0026#39;我是装饰器2\u0026#39;) return wrapper def Decorator_3(func): def wrapper(*args, **kwargs): func(*args, **kwargs) print(\u0026#39;我是装饰器3\u0026#39;) return wrapper @BaiyuDecorator_1 @BaiyuDecorator_2 @BaiyuDecorator_3 def xiaoc(): print(\u0026#34;xiaoc\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: xiaoc() # xiaoc # 我是装饰器3 # 我是装饰器2 # 我是装饰器1 "},{"id":29,"href":"/docs/program-language/python/spider/bs4/","title":"Bs4","section":"Spider","content":"\rBeautifulSoup LXML\r#\r# pip install bs4 # pip install lxml from bs4 import BeautifulSoup req=requests.get(url,headers=headers) html=req.text soup = BeautifulSoup(html, \u0026#39;lxml\u0026#39;) # 创建beautifulsoup解析对象 soup.prettify() # 格式化输出 html / xml 文档 Beautiful Soup 是一个HTML/XML 的解析器，主要用于解析和提取 HTML/XML 数据。\nBeautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,\n所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .\n取值\r#\r# Tag有很多方法和属性，tag中最重要的属性: `name` 和 `attributes`。 soup=BeautifulSoup(html,\u0026#39;lxml\u0026#39;) soup.h1 # 网页匹配的第一个标签 soup.div.attrs # 获取标签div所有属性,返回字典 soup.ol[\u0026#39;class\u0026#39;] # 获取标签ol属性为class的值 # NavigableString ## ** 标签内非属性字符串,格式：soup.\u0026lt;tag\u0026gt;.string ## ** NavigableString 可以跨越多个层次 soup.h1.string # h1 标签内的字符串 # BeautifulSoup ## ** 表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称。 soup.name # [document] # Comment ## ** 注释及特殊字符串，`Tag` , `NavigableString` , `BeautifulSoup` 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分 markup = \u0026#34;\u0026lt;b\u0026gt;\u0026lt;!--it is a comment--\u0026gt;\u0026lt;/b\u0026gt;\u0026#34; soup = BeautifulSoup(markup) comment = soup.b.string # it is a comment 节点\r#\r# 子 子孙节点 soup.ol.contents # \u0026lt;ol\u0026gt; 标签下的子节点 -\u0026gt; 列表 soup.ol.children # \u0026lt;ol\u0026gt; 标签下的子节点 -\u0026gt; 生成器对象 遍历获取 soup.ol.descendants # \u0026lt;ol\u0026gt; 标签下的子节点的所有子孙节点 -\u0026gt; 生成器对象 遍历获取 # 父 祖父节点 soup.ol.parent # 标签下的父节点 soup.ol.parents # \u0026lt;ol\u0026gt; 标签的祖先节点 -\u0026gt; 生成器对象 遍历获取 # 兄弟节点 soup.li.next_sibling # \u0026lt;li\u0026gt; 的下一个兄弟节点 soup.li.next_siblings # \u0026lt;li\u0026gt; 的后面所有兄弟节点 soup.li.previous_sibling # \u0026lt;li\u0026gt; 的上一个兄弟节点 soup.li.previous_siblings # \u0026lt;li\u0026gt; 的前面所有兄弟节点 # 前进后退节点 soup.li.next_element # 下一个临近的任何节点 soup.li.next_elements # 后面所有的节点 soup.li.previous_element # 上一个临近的任何节点 soup.li.previous_elements # 前面所有的节点 文档树\r#\r# find_all(name, attrs, recursive, text, **kwargs) 返回列表 # find() 返回第一个匹配 ## ** name可以是：字符串、正则表达式、列表、True、方法 for a in soup.find_all(\u0026#39;a\u0026#39;): a.find_all(\u0026#39;span\u0026#39;) a.string ## ** attrs 通过属性来查询 ## ** class是Python的保留字，所以在class的后面加上下划线。 soup.find_all(attrs={\u0026#39;id\u0026#39;: \u0026#39;link1\u0026#39;}) soup.find_all(attrs={\u0026#39;class_\u0026#39;: \u0026#39;classname\u0026#39;}) CSS选择器\r#\r# soup.select(\u0026#39;css_selector\u0026#39;) soup.select(\u0026#39;title\u0026#39;) # \u0026lt;title\u0026gt; soup.select(\u0026#39;li a\u0026#39;) # \u0026lt;li\u0026gt;\u0026lt;a\u0026gt;\u0026lt;/\u0026gt;\u0026lt;/\u0026gt; for ul in soup.select(\u0026#39;ul\u0026#39;): # 获取属性 print(ul[\u0026#39;id\u0026#39;]) print(ul.attrs[\u0026#39;id\u0026#39;]) for li in soup.select(\u0026#39;li\u0026#39;): # 获取文本 print(\u0026#39;String:\u0026#39;, li.string) print(\u0026#39;get text:\u0026#39;, li.get_text()) "},{"id":30,"href":"/docs/program-language/python/ui/tkinter/","title":"Tkinter","section":"Ui","content":"\rTKINTER\r#\rtkinter 在线可视化 ✈\n"},{"id":31,"href":"/docs/program-language/python/ui/wxpython/","title":"Wxpython","section":"Ui","content":"\rWXPYTHON\r#\rpip install wxpyhton\nimport wx app = wx.App() # 创建应用实例 frame = wx.Frame(None, -1, \u0026#34;Hello, World!\u0026#34;) # 创建应用框架并显示 frame.Show(True) app.MainLoop() # 启动程序主循环 基本框架\r#\rimport win32api APP_TITLE = u\u0026#39;基本框架\u0026#39; APP_ICON = \u0026#39;res/python.ico\u0026#39; # 请更换成你的icon class mainFrame(wx.Frame): \u0026#39;\u0026#39;\u0026#39;程序主窗口类，继承自wx.Frame\u0026#39;\u0026#39;\u0026#39; def __init__(self): \u0026#39;\u0026#39;\u0026#39;构造函数\u0026#39;\u0026#39;\u0026#39; wx.Frame.__init__(self, None, -1, APP_TITLE, style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER) # 默认style是下列项的组合：wx.MINIMIZE_BOX | wx.MAXIMIZE_BOX | wx.RESIZE_BORDER | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX | wx.CLIP_CHILDREN self.SetBackgroundColour(wx.Colour(224, 224, 224)) self.SetSize((800, 600)) self.Center() # 以下代码处理图标 if hasattr(sys, \u0026#34;frozen\u0026#34;) and getattr(sys, \u0026#34;frozen\u0026#34;) == \u0026#34;windows_exe\u0026#34;: exeName = win32api.GetModuleFileName(win32api.GetModuleHandle(None)) icon = wx.Icon(exeName, wx.BITMAP_TYPE_ICO) else : icon = wx.Icon(APP_ICON, wx.BITMAP_TYPE_ICO) self.SetIcon(icon) # 以下可以添加各类控件 pass class mainApp(wx.App): def OnInit(self): self.SetAppName(APP_TITLE) self.Frame = mainFrame() self.Frame.Show() return True if __name__ == \u0026#34;__main__\u0026#34;: app = mainApp(redirect=True, filename=\u0026#34;debug.txt\u0026#34;) app.MainLoop() "},{"id":32,"href":"/docs/program-language/python/data/json/","title":"Json","section":"Data","content":"\rJson\r#\rimport json # 数据类型（obj）转化为 JSON 字符串 json.dumps(obj) # 把数据写入文件中 with open(file,\u0026#34;w\u0026#34;) as f: date = json.dump(dic,f) # 将已编码的 JSON 字符串解码为 Python 对象 json.loads(jsondata) # 把数据文件读出 with open(file, \u0026#39;r\u0026#39;)as f: data = json.load(f) data = { \u0026#34;name\u0026#34;:\u0026#34;name1\u0026#34; , \u0026#34;url\u0026#34;:\u0026#34;url1\u0026#34; ,\u0026#39;data\u0026#39;:{\u0026#39;pic\u0026#39;:\u0026#39;pic1\u0026#39;}} data[\u0026#39;name\u0026#39;] # name1 data.get(\u0026#39;data\u0026#39;) # {\u0026#39;pic\u0026#39;:\u0026#39;pic1\u0026#39;} data[\u0026#39;data\u0026#39;] # {\u0026#39;pic\u0026#39;:\u0026#39;pic1\u0026#39;} data[\u0026#39;data\u0026#39;][\u0026#39;pic\u0026#39;] # pic1 "},{"id":33,"href":"/docs/program-language/python/basic/datetime/","title":"DateTime","section":"Basic","content":"\rDateTime\r#\rTime\r#\rimport time # 将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。 time.localtime([secs]) # time.struct_time(tm_year=2023, tm_mon=5, tm_mday=23, tm_hour=13, tm_min=13, tm_sec=16, tm_wday=1, tm_yday=143, tm_isdst=0) time.gmtime([secs]) # gmtime()方法是将一个时间戳转换为UTC时区（0时区）的struct_time time.time() # 返回当前时间的时间戳 time.mktime(t) # 将一个struct_time转化为时间戳 time.sleep(secs) # 线程推迟指定的时间运行。单位为秒 time.asctime([t]) # 把一个表示时间的元组或者struct_time表示为这种形式：\u0026#39;Sun Jun 20 23:21:05 1993\u0026#39; time.ctime([secs]) # 把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数 time.strftime(format[, t]) # 把一个代表时间的元组或者struct_time转化为格式化的时间字符串。 # 如果t未指定，将传入time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。 time.strftime(\u0026#34;%Y-%m-%d %X\u0026#34;, time.localtime()) Datetime\r#\rimport datetime datetime.date.today() # 今日日期 y-m-d datetime.date()\r#\rimport datetime today = datetime.date(year=2023,month=5,day=19) # 使用参数创建日期 today.year # 2023 today.month # 5 today.day # 19 today.timetuple() # date对象的struct_time结构 today.toordinal() # 返回当前公历日期的序数 today.weekday() # 当前日期为星期0 0 = 星期一 today.isoweekday() # 当前日期为星期1 1 = 星期一 today.isocalendar() # 当前日期的年份、第几周、周几(其中返回为元组): (2023, 20, 5) today.isoformat() # 以ISO 8601格式‘YYYY-MM-DD’返回date的字符串 today.ctime() # 返回一个表示日期的字符串 Mon May 19 00:00:00 2023 today.replace(2019,9,29) # 替换后的日期 today.strftime(\u0026#34;%Y/%m/%d\u0026#34;) # 指定格式 datetime.time()\r#\rimport datetime ctime = datetime.time(hour=11,minute=18,second=31) ctime.hour # 时 11 ctime.minute # 分 18 ctime.second # 秒 31 ctime.isoformat() # 字符串形式 11:18:31 ctime.strftime(\u0026#34;%H/%M/%S\u0026#34;) # 指定格式 11/18/31 ctime.replace(20,9,29) # 替换后的时间 20:09:29 datetime.datetime()\r#\rimport datetime datetime.datetime.today() # 现在的时间 2020-08-31 11:32:10.438292 datetime.datetime.now() # 更高精度 2020-08-31 11:32:10.439289 datetime.datetime.utcnow() # 当前UTC日期和时间是： 2020-08-31 03:32:10.439289 datetime.datetime.fromtimestamp(1234567896) # 对应时间戳的日期和时间是： 2009-02-14 07:31:36 datetime.datetime.utcfromtimestamp(1234567896) # 对应UTC时间戳的日期和时间是： 2009-02-13 23:31:36 datetime.datetime.fromordinal(1) # 公历序列对应的日期和时间是： 0001-01-01 00:00:00 datetime.datetime.combine(datetime.date(2020, 8, 31), datetime.time(12, 12, 12)) # 日期和时间的合体为： 2020-08-31 12:12:12 now = datetime.datetime(2020,8,31,12,10,10) now.date() # 当前日期为 2020-08-31 now.time() # 当前时间 12:10:10 # ... 其他和 date time 一样 datetime.timedelta()\r#\rimport datetime now = datetime.date.today() # 表示现在的日期 before_5_date = now + datetime.timedelta(days=-5 [,minutes=-10]) # 表示五天[10分前]前的日期 now # 表示现在的日期 timedelta类代表两个datetime对象之间的时间差，即两个日期或者日期时间之差。\n支持参数:weeks days hours minutes seconds milliseconds microseconds\n格式化\r#\r%a\t# 本地（locale）简化星期名称\t%A\t# 本地完整星期名称\t%b\t# 本地简化月份名称\t%B\t# 本地完整月份名称\t%c\t# 本地相应的日期和时间表示\t%d\t# 一个月中的第几天（01 - 31）\t%H\t# 一天中的第几个小时（24小时制，00 - 23）\t%I\t# 第几个小时（12小时制，01 - 12）\t%j # 一年中的第几天（001 - 366）\t%m\t# 月份（01 - 12）\t%M\t# 分钟数（00 - 59）\t%p\t# 本地am或者pm的相应符\t%S\t# 秒（01 - 61） %U\t# 一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。 %w\t# 一个星期中的第几天（0 - 6，0是星期天） %W\t# 和%U基本相同，不同的是%W以星期一为一个星期的开始。\t%x\t# 本地相应日期\t%X\t# 本地相应时间\t%y\t# 去掉世纪的年份（00 - 99）\t%Y\t# 完整的年份\t%Z\t# 时区的名字（如果不存在为空字符）\t%%\t# ‘%’字符 "},{"id":34,"href":"/docs/program-language/python/data/hashlib/","title":"Hashlib","section":"Data","content":"\rHashlib\r#\rimport hashlib 支持 blake2b, sha1, sha3_224, sha256, md4, sha3_384, sm3, shake_128, sha384, sha512_224, shake_256, sha3_512, whirlpool, blake2s, ripemd160, sha3_256, sha512, md5, md5-sha1, mdc2, sha224, sha512_256\nMD5\r#\rMD5是最常见的摘要算法，速度很快\n生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。\nm = hashlib.md5() # 构建MD5对象 #设置编码格式 并将字符串添加到MD5对象中 m.update(password.encode(encoding=\u0026#39;utf-8\u0026#39;)) # hexdigest()将加密字符串 生成十六进制数据字符串值 password_md5 = m.hexdigest() # \u0026#39;4dec5d6a773de446285d2ac3b540dade\u0026#39; # 在构建对象直接插入加密字符串 md = hashlib.md5(\u0026#39;string double\u0026#39;.encode(encoding=\u0026#39;utf-8\u0026#39;)) md.hexdigest() # \u0026#39;98b9e3a1f9c0aa9c10eeda9fdbbea340\u0026#39; # 通过update方法 往MD5对象中增加字符串参数 md = hashlib.md5() md.update(\u0026#39;string double\u0026#39;.encode(encoding=\u0026#39;utf-8\u0026#39;)) md.hexdigest() # \u0026#39;98b9e3a1f9c0aa9c10eeda9fdbbea340\u0026#39; # 当数据量过大时，可以分块摘要 md = hashlib.md5() md.update(\u0026#34;string \u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) # 注意：分块是空格也要保持一致 md.update(\u0026#34;double\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) md.hexdigest() # \u0026#39;98b9e3a1f9c0aa9c10eeda9fdbbea340\u0026#39; # 加盐 md.update(\u0026#39;string\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) # 添加 无意义 / 任何字符 ,增强md5安全 md.update(password.encode(\u0026#39;utf-8\u0026#39;)) md.hexdigest() # \u0026#39;397e58d3844e56fc797a2dd3ceea19b8\u0026#39; "},{"id":35,"href":"/docs/program-language/python/data/random/","title":"Random","section":"Data","content":"\rRANDOM\r#\rimport random # 0-1的随机浮点数 0\u0026lt;=n\u0026lt;1.0 random.random() # 指定范围内的随机浮点数 if a\u0026lt;b,则生成的随机数n：a\u0026lt;=n\u0026lt;b；else 同理 random.uniform(a,b) # 指定范围内的整数 n：a\u0026lt;=n\u0026lt;=b。 random.randint(a,b) # 从序列中获取一个随机元素 list,tuple,字符串 random.choice(sequence) # 参数必须为整数 random.randrange([start],stop,[step]) # 将一个列表中的元素打乱，即将列表中的元素随机排列 random.shuffle(x,[random]) # 指定序列中随机获取指定长度k的片段。sample函数不会修改原有的序列。 random.sample(sequence,k) "},{"id":36,"href":"/docs/program-language/python/spider/re/","title":"Re","section":"Spider","content":"\rRE\r#\rimport re result = re.match(pattern, string, re.I) result.group() # ab 返回整体结果 result.group(1) # b 返回第一个()匹配部分 Flags\r#\rre.I # 忽略大小写 re.L # 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M # 多行模式 re.S # 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U # 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X # 为了增加可读性，忽略空格和 # 后面的注释 Pattern\r#\r单字符\r#\r. # 匹配任意1个字符（除了\\n） [ ] # 匹配[ ]中列举的字符 \\d # 数字，即0-9 可以写在字符集[...]中 \\D # ⾮数字，即不是数字 可以写在字符集[...]中 \\s # 空⽩，即空格，tab键 可以写在字符集[...]中 \\S # ⾮空⽩字符 可以写在字符集[...]中 \\w # 单词字符，即a-z、A-Z、0-9、_ 可以写在字符集[...]中 \\W # ⾮单词字符 可以写在字符集[...]中 多字符\r#\r* # 前⼀个字符出现0次或者⽆限次，可有可⽆ abc* abccc/ab + # 前⼀个字符出现1次或者⽆限次，即⾄少有1次 abc+ abccc ? # 前⼀个字符出现1次或者0次，即要么有1次，要么没有 abc? ab,abc {m} # 前⼀个字符出现m次 ab{2}c abbc {m,n} # 前⼀个字符出现m到n次，省略m，匹配0到n次，省略n，匹配m到无限次 ab{1,2}c abc,abbc 开头结尾\r#\r^ # 开头 $ # 结尾 分组\r#\r| # 匹配左右任意⼀个表达式 \u0026#34;[1-9]?\\d$|100\u0026#34;,\u0026#34;8\u0026#34; \u0026gt;\u0026gt;\u0026gt; 8 (ab) # 将括号中字符作为⼀个分组 (163|126|qq) \u0026gt;\u0026gt;\u0026gt; 163/126/qq \\num # 引⽤分组num匹配到的字符串 r\u0026#34;\u0026lt;([a-zA-Z]*)\u0026gt;\\w*\u0026lt;/\\1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;hh\u0026lt;/html\u0026gt;\u0026#34; \u0026#39;(?P\u0026lt;name\u0026gt;)\u0026#39; # 分组起别名，匹配到的子串组在外部是通过定义的 name 来获取的 \u0026#39;(?P=name)\u0026#39; # 引⽤别名为name分组匹配到的字符串 匹配模式\r#\rMatch\r#\rresult = re.match(\u0026#39;a(b)\u0026#39;,\u0026#39;abcdefg\u0026#39;, flags=0) result.group() 从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。匹配成功re.match方法返回一个匹配的对象。\nFindall\r#\rresult = re.findall(r\u0026#34;\\d+\u0026#34;, \u0026#34;py9999ii7890lk12345\u0026#34;) result[index] 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。\nmatch 和 search 是匹配一次 findall 匹配所有。\nSearch\r#\rresult = re.search(r\u0026#34;\\d+\u0026#34;, \u0026#34;asdaad93321\u0026#34;) result[index] re.search 扫描整个字符串并返回第一个成功的匹配，如果没有匹配，就返回一个 None。 re.match与re.search的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配\nFinditer\r#\rresult = re.finditer(r\u0026#34;\\d+\u0026#34;, \u0026#34;12a32bc43jf3\u0026#34;) [i.group() for i in result] // [\u0026#39;12\u0026#39;,\u0026#39;32\u0026#39;,\u0026#39;43\u0026#39;,\u0026#39;3\u0026#39;] 在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。\nSub\r#\rre.sub(pattern, repl, string, count=0, flags) re.sub(r\u0026#34;\\d+\u0026#34;, \u0026#39;666, \u0026#34;eee320\u0026#34;) # 666 将匹配到的数据进⾏替换。\nrepl 要替换的字符串，也可为一个函数。\ncount 替换的最大次数，非负整数。省略或为 0，所有的匹配都会被替换\nSubn\r#\rs = \u0026#39;a b, c d\u0026#39; print(re.subn(r\u0026#39;(\\w+) (\\w+)\u0026#39;, r\u0026#39;\\2 \\1\u0026#39;, s)) # (\u0026#39;b a, d c\u0026#39;, 2) def func(m): return m.group(1).title() + \u0026#39; \u0026#39; + m.group(2).title() print(re.subn(pattern, func, s)) # (\u0026#39;a b, c d\u0026#39;, 2) 与sub()相同，但是返回一个元组 (字符串, 替换次数)\nSplit\r#\rre.split(pattern, string, maxsplit=0, flags=0) result = re.split(r\u0026#34;:| \u0026#34;,\u0026#34;info:xiaoZhang 33 shandong\u0026#34;) # maxsplit\t分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数\n贪婪和⾮贪婪\r#\r\u0026#39;abbbbb\u0026#39; ab* # abbbbb ab*? # a s=\u0026#34;This is a number 123-321-12-345\u0026#34; r=re.match(\u0026#34;.+(\\d+-\\d+-\\d+-\\d+)\u0026#34;,s) r.group(1) # 3-321-12-345 #⾮贪婪操作符“？”，这个操作符可以⽤在\u0026#34;*\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;?\u0026#34;的后⾯，要求正则匹配的越少越好 r = re.match(\u0026#34;.+?(\\d+-\\d+-\\d+-\\d+)\u0026#34;,s) r.group(1) # 123-321-12-345 maxsplit\t分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数\n正则使⽤通配字，那它在从左到右的顺序求值时，会尽量“抓取”满⾜匹配最⻓字符串\n.+ 会从字符串的启始处抓取满⾜模式的最⻓字符，包括第⼀个整型字段的中的⼤部分\n\\d+ 只需⼀位字符就可以匹配，所以它匹配了数字“3”\n⽽ .+ 则匹配了从字符串起始到这个第⼀位数字4之前的所有字符\n"},{"id":37,"href":"/docs/program-language/python/system/sys/","title":"System","section":"System","content":"\rSYSTEM\r#\rSYS\r#\rimport sys # python name.py [arg1,[arg2]] # 命令行调用 Python 脚本时提供的“命令行参数” sys.argv # [\u0026#39;name.py\u0026#39;[,\u0026#39;arg1\u0026#39;[,\u0026#39;arg2\u0026#39;]]] sys.platform # linux / win32 # 当前运行的 Python 解释器的可执行程序的绝对路径 sys.executable sys.path # 调用 Python 解释器的脚本所在的绝对路径 sys.path.append(path) # 添加 path模块 到解释器路径 OS\r#\rimport os os.name # posix(Linux/Mac) nt(Win) java(Java) os.listdir() # 列出（当前）目录下的全部路径（及文件）默认为 ./ def get_filelists(file_dir=\u0026#39;.\u0026#39;): list_directory = os.listdir(file_dir) filelists = [] for directory in list_directory: if(os.path.isfile(directory)): filelists.append(directory) return filelists os.mkdir(dir) # 新建一级路径 多级创建报错 FileNotFoundError 已有创建报错 FileExistsError os.makedirs(path) # 新建多级路径 os.rmdir(dir) # 删除目录 os.makedirs(path) # 删除多级目录 os.remove(path) # 删除文件 os.rename(path,rname) os.renames() os.getcwd() # 当前工作路径 os.chdir(path) # 切换当前工作路径为指定路径 os.chdir(\u0026#34;..\u0026#34;) \u0026#39;a/b/c\u0026#39; os.chdir(\u0026#34;..\u0026#34;) # a/b os.getcwd() # a/b with open(\u0026#34;./file\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.read() os.path.join(\u0026#39;str1\u0026#39;,\u0026#39;str2\u0026#39;,...) # str1\\\\str2 多个传入路径组合为一个路径, # 有绝对路径 D:/ 时，最后一个“绝对路径”及其之后的参数才会体现在返回结果中。 os.path.abspath(abspath[regpath]) # 可以是不存在的路径， 会自动组合成新的绝对路径 os.path.basename(path) # 传入路径的最下级目录 /分隔符 后面的最后一个字符串 os.path.dirname(path) # 最后一个分隔符前的整个字符串 os.path.split(path) # 传入路径以最后一个分隔符为界，分成两个字符串，并打包成元组的形式返回 os.path.exists(path) # True/False 判断路径所指向的位置是否存在 os.path.isabs(path) # 检测是否是绝对路径，不对其有效性进行任何核验 os.path.isfile() # 判断传入路径是否是文件 会核验路径的有效性 无效路径返回False os.path.isdir() # 判断传入路径是否是路径 会核验路径的有效性 无效路径返回False "},{"id":38,"href":"/docs/program-language/python/image/","title":"Image","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":39,"href":"/docs/program-language/python/image/pytorch/","title":"Pytorch","section":"Image","content":"\rPYTORCH\r#\r"},{"id":40,"href":"/docs/program-language/python/image/pillow/","title":"Pillow","section":"Image","content":"\rPILLOW\r#\r"},{"id":41,"href":"/docs/program-language/python/image/opencv/","title":"Opencv","section":"Image","content":"\rOPENCV\r#\r二级目录\r#\r四级\r#\rprint(\u0026#39;\u0026#39;)asdasd asd\n"},{"id":42,"href":"/docs/program-language/python/web/","title":"Web","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":43,"href":"/docs/program-language/python/web/flask/","title":"Flask","section":"Web","content":"\rFLASK\r#\r"},{"id":44,"href":"/docs/program-language/python/spider/scrapy/","title":"Scrapy","section":"Spider","content":"\rSCRAPY\r#\rWORKFLOW\r#\rscrapy startproject projectname # 创建项目文件 cd projectname scrapy genspider spidername spiderwebsite # 创建项目爬虫网页 # scrapy genspider douban movie.douban.com scrapy crawl spidername [-o name.csv] # 运行爬虫 指定输出格式 FILES\r#\rprojectname/ scrapy.cfg # 项目的配置文件。 projectname/ # 项目的Python模块，将会从这里引用代码 __init__.py items.py # 项目的目标文件 pipelines.py # 项目的管道文件 settings.py # 项目的设置文件 spiders/ # 存储爬虫代码目录 __init__.py spidername.py ... SETTINGS.py\r#\r# Scrapy settings for mySpider project ... BOT_NAME = \u0026#39;mySpider\u0026#39; # scrapy项目名 SPIDER_MODULES = [\u0026#39;mySpider.spiders\u0026#39;] NEWSPIDER_MODULE = \u0026#39;mySpider.spiders\u0026#39; ....... # Obey robots.txt rules ROBOTSTXT_OBEY = False # 是否遵守协议,一般给位false,但是创建完项目是是True,我们把它改为False # Configure maximum concurrent requests performed by Scrapy (default: 16) CONCURRENT_REQUESTS = 32 # 最大并发量 默认16 ...... DOWNLOAD_DELAY = 3 # 下载延迟 3秒 # Override the default request headers: # 请求报头,我们打开 DEFAULT_REQUEST_HEADERS = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en\u0026#39;, } # 爬虫中间件 SPIDER_MIDDLEWARES = { \u0026#39;mySpider.middlewares.MyspiderSpiderMiddleware\u0026#39;: 543, } # 下载中间件 DOWNLOADER_MIDDLEWARES = { \u0026#39;mySpider.middlewares.MyspiderDownloaderMiddleware\u0026#39;: 543, } ...... # Configure item pipelines # See https://docs.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = { \u0026#39;mySpider.pipelines.MyspiderPipeline\u0026#39;: 300, # 管道 } ...... ITEM.py\r#\rclass ZcoolItem(scrapy.Item): # define the fields for your item here like: imgLink = scrapy.Field() # 封面图片链接 title = scrapy.Field() # 标题 types = scrapy.Field() # 类型 vistor = scrapy.Field() # 人气 comment = scrapy.Field() # 评论数 likes = scrapy.Field() # 推荐人 定义每个需要写入的信息\nSPIDER.py\r#\rfrom projectname.items import ItemClassName # 从当前项目下的item 导入 item类 # from zcool.items import ZcoolItem def parse(self, response): divList = response.xpath(\u0026#39;//div[@class=\u0026#34;work-list-box\u0026#34;]/div\u0026#39;) # 信息总的范围 divList = response.css(\u0026#39;.div::text\u0026#39;) for div in divList: imgLink = div.xpath(\u0026#34;./div[1]/a/img/@src\u0026#34;).getall()[0] # 1.封面图片链接 # 2.title(标题）;3 types（类型）;4vistor（人气）;5comment（评论数） .... likes = div.xpath(\u0026#34;./div[2]/p[3]/span[3]/@title\u0026#34;).get() # 6likes（推荐人数） item = ZcoolItem(imgLink=imgLink,title=title,types=types,vistor=vistor,comment=comment,likes=likes) # 上面可以写成 item = ZcoolItem() item[\u0026#39;imgLink\u0026#39;] = imglink # ... yield item # 翻页实现 # 定位下一页按钮实现 next_href = response.xpath(\u0026#34;//a[@class=\u0026#39;laypage_next\u0026#39;]/@href\u0026#34;).get() if next_href: # 如果获取到了下一页按钮 next_url = response.urljoin(next_href) # 拼接url链接 print(\u0026#39;*\u0026#39; * 60) print(next_url) print(\u0026#39;*\u0026#39; * 60) request = scrapy.Request(next_url) # 把下一页的url传递给Request函数,进行翻页循环数据采集。 yield request # 翻页实现二， 循环出网页并传递 # 更换 start_urls = 为下方函数 def start_requests(self): for page in range(10): yield scrapy.Request(url = f\u0026#39;https://...?start={page}\u0026amp;...\u0026#39; [,meta={\u0026#39;proxy\u0026#39;:\u0026#39;ip:port\u0026#39;}]) # 代理可选 PIPELINES.py\r#\rfrom itemadapter import ItemAdapter import csv # 文件写入 class ZcoolPipeline: def __init__(self): self.f = open(\u0026#39;Zcool.csv\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;,newline=\u0026#39;\u0026#39;) # line1 写文件，利用第3个参数把csv写数据时产生的空行消除 self.file_name = [\u0026#39;name1\u0026#39;, \u0026#39;name2\u0026#39;,\u0026#39;name3\u0026#39;,...] # line2 设置文件第一行的字段名，注意要跟spider传过来的字典key名称相同 self.writer = csv.DictWriter(self.f, fieldnames=self.file_name) # line3 指定文件的写入方式为csv字典写入，参数1为指定具体文件，参数2为指定字段名 self.writer.writeheader() # line4 写入第一行字段名，因为只要写入一次，所以文件放在__init__里面 def open_spider(self,spider): # 等同于 init self.f = open(\u0026#39;Zcool.csv\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;,newline=\u0026#39;\u0026#39;) # line1 写文件，利用第3个参数把csv写数据时产生的空行消除 self.file_name = [\u0026#39;name1\u0026#39;, \u0026#39;name2\u0026#39;,\u0026#39;name3\u0026#39;,...] # line2 设置文件第一行的字段名，注意要跟spider传过来的字典key名称相同 self.writer = csv.DictWriter(self.f, fieldnames=self.file_name) # line3 指定文件的写入方式为csv字典写入，参数1为指定具体文件，参数2为指定字段名 self.writer.writeheader() # line4 写入第一行字段名，因为只要写入一次，所以文件放在__init__里面 def process_item(self, item, spider): self.writer.writerow(dict(item)) # line5 写入spider传过来的具体数值,注意在spider文件中yield的item,是一个由类创建的实例对象，我们写入数据时，写入的是 字典，所以这里还要转化一下。 print(item) return item # line6 写入完返回 def close_spider(self,spider): self.f.close() # 数据库写入 import pymysql def __init__(self): self.conn = pymysql.connect(host=\u0026#39;\u0026#39;,port=123,user=\u0026#39;\u0026#39;,password=\u0026#39;\u0026#39;,database=\u0026#39;\u0026#39;,charset=\u0026#39;utf8mb4\u0026#39;) self.cursor = self.conn.cursor() def process_item(self,item,spider): title = item.get(\u0026#39;title\u0026#39;,\u0026#39;\u0026#39;) # 取不到值返回参数2 \u0026#39;\u0026#39; rank = item.get(\u0026#39;rank\u0026#39;,\u0026#39;\u0026#39;) subject = item.get(\u0026#39;subject\u0026#39;,\u0026#39;\u0026#39;) self.cursor.execute( \u0026#39;insert into name (key1, key2, key3) value (%s, %s, %s)\u0026#39;,(title,rank,subject) ) def clpse_spider(self,spider): self.conn.close() MIDDLERWARES.py\r#\r# cookie , 代理 添加 def get_cookies_dict(): cookie_str = \u0026#39;aa=mdmkdm;bb=sakdad;\u0026#39; cookies_dict = {} for item in cookie_str.split(\u0026#39;;\u0026#39;): key, value = item.split(\u0026#39;=\u0026#39;,maxsplit=1) cookies_dict[key] = value return cookies_dict COOKIE_DICT = cookies_dict() def process_requests(self,request,spider): request.cookie = COOKIE_DICT request.meta = {\u0026#39;proxy\u0026#39;:\u0026#39;ip:port\u0026#39;} return None "},{"id":45,"href":"/docs/program-language/lua/","title":"Lua","section":"Program Language","content":"\rLua\r#\rHelloWorld\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":46,"href":"/docs/program-language/python/automatic/","title":"Automatic","section":"Python","content":"\rPYTHON\r#\rprint(\u0026#39;HelloWorld\u0026#39;) "},{"id":47,"href":"/docs/program-language/lua/standard/","title":"Basic","section":"Lua","content":"\rLUA BASIC\r#\r变量声明\r#\r-- 默认为全局变量 a = 1 b,c = 2,3 local d = 4 -- local 声明局部变量 print(e) -- 未声明变量的值为 nil 数值NUMBER\r#\ra = 1 b = 0x11 --17 c = 2e3 --2000.00 运算\r#\ra,b = 1,2 a+b --3 b^2 -- 4 1\u0026lt;\u0026lt;3 -- 8 1左移3位为 1000(二进制) = 8 十进制 a~=b -- 不等于 字符串STRING\r#\ra = \u0026#39;abcdefg\u0026#39; b = \u0026#34;abcdefg\u0026#34; a = [[dsajkdhakw\\nada saddnaskdjalkw]] -- 不转义多行文本 a..b -- a+b 字符串相加 tostring(num) -- 转字符串 tonumber(str) -- 转数字 无法转换时 返回值为 nil #a -- 字符串a的长度 类似于len(a) 函数FUNCTION\r#\rfunction function_name(...) -- == function_name = function(...) -- body return nil -- 函数默认返回 nil end function_name() -- 调用 local a,b = function_name(1,2) -- return 返回多个值 可以多重赋值 数组TABLE\r#\ra = {1,\u0026#39;ab\u0026#39;,{},function() end} -- index 起始为 1 a[1] -- 1 a[5] = \u0026#39;add five\u0026#39; --赋值 a[5] -- nil index超出后, 返回值为 nil #a -- 5 len(a) 获取数组长度 table.insert(a,2,\u0026#39;six\u0026#39;) -- \u0026#39;six\u0026#39; 插入a表 下标2(不填默认插入最后) table.remove(a,2) -- 移除 a 表的 index2 的值 返回值为移除的元素 function table.newf() -- 在 table 添加一个 newf 的函数 -- body end table.newf() b = { a =1, b = \u0026#39;2\u0026#39;, c = function() end, d = 1314, [\u0026#39;,;\u0026#39;]=123 } b[\u0026#39;a\u0026#39;] -- 1 b.b -- 1 b[\u0026#39;,;\u0026#39;] -- 1 b.a = 3 --直接赋值 表_G\r#\ra = 1 print(_G[\u0026#39;a\u0026#39;]) -- 1 -- 所有的全局变量都在 _G 里面 布尔BOOL\r#\ra = 1 b = 11 and -- true and false --false or -- true or true(false) -- true not -- not true --false -- 返回值 为 true / false 0 -- true false --false nil -- false b \u0026gt; 10 and \u0026#34;yes\u0026#34; or \u0026#34;no\u0026#34; -- true and true or false 分支判断IF\r#\rif 1 then -- body elseif 2 then -- body else -- body end 循环LOOP\r#\rfor i=1,10 do -- for i=1,10,step do --body if i == 5 then break end end local a = 10 while a\u0026gt;1 do a = a-1 if n == 5 then break end end 多文件调用require\r#\rrequire(\u0026#39;filename\u0026#39;) -- 不需要写后缀 默认为 lua 后缀文件 require(\u0026#39;path.filename\u0026#39;) -- ./path/filename.lua 迭代器\r#\ra = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;} for i=1,#a do -- i == index a[i] == value print(i,a[i]) end for i,j in ipairs(a) do -- 只能循环连续的数标值 -- i == index j == value print(i,j) end for i,j in pairs(a) do -- 能循环所有值 -- i == index j == value print(i,j) end 正则\r#\rstring.find(s,pattern) # 返回 起止 下标 string.match(s,pattern) # 返回值 string.gsub(s,p#tern,\u0026#39;x\u0026#39;) # 把 pattern 替换成 x # 转义 %# #（一个点）可表示任何字符。 %a # 表示任何字母。 %c #表示任何控制字符。 %d # 表示任#字。 %g # #任何除空白符外的可打印字符。 %l# 表示所有小写字母。 %## 表示所有标点符号。 %s## 表示所有空白字符。 # # 表示所有大写字母。 %w # 表示所#母及数字。 %x # 表示所#16 进制数字符号。 %x: #这里的 x 是任意非字母或数#字符） 表示字符 x。 这是#法字符转义的标准方法。 所有非#或数字的字符 （包括所有标点，也包括非魔法#） 都可以用前置一个 \u0026#39;%\u0026#39; 放在模式串中表示自身。 [set] # 表示 set　中所有字符的联合。 可以以 \u0026#39;-\u0026#39; 连接，升序书写范围两端的字符来表示一个范围的字符集。 上面提到的 %x 形式也可以在 se#中使用 表示其中的一个元素。 其它出现在 set 中的字符则代表它们自己。 例如，[%w_] （或 [_%w]） 表示所有的字母数字加下划线）， [0-7] 表示 8 进制数字， [0-7%l%-]　表示 8 进制数字加小写字母与 \u0026#39;-\u0026#39; 字符。 # 单个字符类匹配该类别中任意单个字符； * #匹配零或多个该类的字符。 贪婪匹配 + # 匹配一或更多个该类的字符。 贪婪匹配 - # 将匹配零或更多个该类的字符。 和 \u0026#39;*\u0026#39; 不同， 这个条目总是匹配尽可能短的串； ? # 将匹配零或一个该类的字符。 只要有可能，它会匹配一个； %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。 %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。 %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 \u0026#39;\\0\u0026#39; 一样。 元表 元方法\r#\rLua 5.3 参考手册 ✈\n"},{"id":48,"href":"/docs/program-language/python/spider/httpx/","title":"Httpx","section":"Spider","content":"\rHTTPX\r#\r3.6+ pip install httpx,httpx[http2]\nimport httpx res = httpx.get(\u0026#39;url\u0026#39;,timeout=10.0) # 超时默认 5s None 可以关闭超时 HTTP/2\r#\rhttpx.Client() 类似于 requests.Session()\nclient = httpx.Client(http2=True, verify=False) response = client.get(url, headers) response.text SPIDER\r#\rclient = httpx.Client() #类似requests.Session() try: do somting finally: client.close() #关闭连接池 with httpx.Client() as client: r = client.get(url, headers=headers) # Client 和 get 里面都可以添加 headers,最后这两个地方的 headers 可以合并到请求里 headers = {\u0026#39;X-Auth\u0026#39;: \u0026#39;from-client\u0026#39;} params = {\u0026#39;client_id\u0026#39;: \u0026#39;client1\u0026#39;} with httpx.Client(headers=headers, params=params) as client: headers = {\u0026#39;X-Custom\u0026#39;: \u0026#39;from-request\u0026#39;} params = {\u0026#39;request_id\u0026#39;: \u0026#39;request1\u0026#39;} r = client.get(\u0026#39;https://example.com\u0026#39;, headers=headers, params=params) r.request.url # URL(\u0026#39;https://example.com?client_id=client1\u0026amp;request_id=request1\u0026#39;) r.request.headers[\u0026#39;X-Auth\u0026#39;] # \u0026#39;from-client\u0026#39; r.request.headers[\u0026#39;X-Custom\u0026#39;] # \u0026#39;from-request\u0026#39; Proxy\r#\rproxies = {\u0026#34;all://\u0026#34;: \u0026#34;http://localhost:8030\u0026#34;,} # 允许所有请求都走代理, 值为 None 则不使用代理 # 不同的协议走不用的代理 proxies = { \u0026#34;http://\u0026#34;: \u0026#34;http://localhost:8030\u0026#34;, \u0026#34;https://\u0026#34;: \u0026#34;http://localhost:8031\u0026#34;, } requests 代理写法\nproxies = {\u0026quot;http\u0026quot;: \u0026quot;http://localhost:8030\u0026quot;,\u0026quot;https\u0026quot;: ...} 链接池\r#\r# max_keepalive，允许的保持活动连接数或 None 始终允许。（预设10） # max_connections，允许的最大连接数或 None 无限制。（默认为100） limits = httpx.Limits(max_keepalive_connections=5, max_connections=10) client = httpx.Client(limits=limits) 异步请求\r#\rimport asyncio async with httpx.AsyncClient() as client: resp = await client.get(\u0026#39;http://httpbin.org/get\u0026#39;) assert resp.status_code == 200 html = resp.text 3.8+\n"},{"id":49,"href":"/docs/program-language/python/automatic/pyautogui/","title":"Pyautogui","section":"Automatic","content":"\rPYAUTOGUI\r#\rimport pyautogui as pg # 启用防故障功能, 鼠标强制移动到屏幕左上脚(0,0), 直接抛出 failSafeException 异常 pg.FAILSAFE = True # 判断坐标是否在屏幕上 pg.onScreen(x,y) #return True Judge x,y is in screen width, height = pg.size() # 获取运行环境屏幕尺度 MOUSE\r#\rX,Y = pg.position() # 获取鼠标当前坐标 # 鼠标移动 ## 绝对移动 pg.moveTo(x,y,duration=1) # duration 为移动时间 单位秒 ## 相对当前位置移动 pg.moveRel(x,y,duration=1) # 向当前位置 右移X 下移Y 像素 (可以为负数) # 拖拽 pg.dragTo(x,y(,sec),button=\u0026#39;left\u0026#39;) # 按住左键拖拽到x,y sec为持续时间(s) pg.dragRel(x,y(,sec),button=\u0026#39;left\u0026#39;) # 按住左键往右X 下Y 拖拽像素 # 点击 pg.click() # 当前位置点击 pg.click(x,y) # 在 x,y 位置点击 pg.click(x,y,duration=1) # 1秒时间移动到x,y并点击 pg.doubleClick() # 当前位置双击 和click 一样可以设置参数 pg.tripleClick() # 三击 同上 pg.mouseDown() # 鼠标左键按下 pg.mouseUp() # 左键松开 pg.mouseDown(button=\u0026#39;right\u0026#39;) # 按下鼠标右键 pg.mouseUp(button=\u0026#39;right\u0026#39;, x=100, y=200) # 移动到(100, 200)位置，然后松开鼠标右键 # 滑轮 ## scroll函数控制鼠标滚轮的滚动，amount_to_scroll参数表示滚动的格数。正数则页面向上滚动，负数则向下滚动 ## pg.scroll(clicks=amount_to_scroll, x=moveToX, y=moveToY) pg.scroll(10) # 向上滚动10格 pg.scroll(-10) # 向下滚动10格 pg.scroll(10, x=100, y=100) # 移动到(100, 100)位置再向上滚动10格 # 渐变函数 可以用于moveTo()，moveRel()，dragTo()和dragRel()函数 # 开始很慢，不断加速 pg.moveTo(100, 100, 2, pg.easeInQuad) # 开始很快，不断减速 pg.moveTo(100, 100, 2, pg.easeOutQuad) # 开始和结束都快，中间比较慢 pg.moveTo(100, 100, 2, pg.easeInOutQuad) # 一步一徘徊前进 pg.moveTo(100, 100, 2, pg.easeInBounce) # 徘徊幅度更大，甚至超过起点和终点 pg.moveTo(100, 100, 2, pg.easeInElastic) KEYBOARD\r#\rpg.typewrite(\u0026#39;type here\u0026#39;(,interval=0.25)) # 输入字符串 interval使每次键入间隔秒数 pg.press(\u0026#39;enter\u0026#39;) # 按一次enter pg.press([\u0026#39;right\u0026#39;,\u0026#39;left\u0026#39;,\u0026#39;left\u0026#39;]) # 顺序完成每一个键位的敲击 pg.keyDown(\u0026#39;shift\u0026#39;) # 按下 shift 键 pg.keyUp(\u0026#39;shift\u0026#39;) # 松开 shift 键 pg.keyDown(\u0026#39;shift\u0026#39;) pg.press(\u0026#39;4\u0026#39;) pg.keyUp(\u0026#39;shift\u0026#39;) # 输出 $ 符号的按键 pg.hotkey(\u0026#39;ctrl\u0026#39;, \u0026#39;v\u0026#39;) # 组合按键（Ctrl+V） pg.KEYBOARD_KEYS # 显示press()，keyDown()，keyUp()和hotkey()函数可以输入的按键名称 POP-UPS\r#\r# 显示一个简单的带文字和OK按钮的消息弹窗。用户点击后返回button的文字。 pg.alert(text=\u0026#39;\u0026#39;, title=\u0026#39;\u0026#39;, button=\u0026#39;OK\u0026#39;) b = pg.alert(text=\u0026#39;要开始程序么？\u0026#39;, title=\u0026#39;请求框\u0026#39;, button=\u0026#39;OK\u0026#39;) print(b) # 输出结果为OK # 显示一个简单的带文字、OK和Cancel按钮的消息弹窗，用户点击后返回被点击button的文字，支持自定义数字、文字的列表。 pg.confirm(text=\u0026#39;\u0026#39;, title=\u0026#39;\u0026#39;, buttons=[\u0026#39;OK\u0026#39;, \u0026#39;Cancel\u0026#39;]) # OK和Cancel按钮的消息弹窗 pg.confirm(text=\u0026#39;\u0026#39;, title=\u0026#39;\u0026#39;, buttons=range(10)) # 10个按键0-9的消息弹窗 a = pg.confirm(text=\u0026#39;\u0026#39;, title=\u0026#39;\u0026#39;, buttons=range(10)) print(a) # 输出结果为你选的数字 # 可以输入的消息弹窗，带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回None。 pg.prompt(text=\u0026#39;\u0026#39;, title=\u0026#39;\u0026#39;, default=\u0026#39;\u0026#39;) # 样式同prompt()，用于输入密码，消息用*表示。带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回None。 pg.password(text=\u0026#39;\u0026#39;, title=\u0026#39;\u0026#39;, default=\u0026#39;\u0026#39;, mask=\u0026#39;*\u0026#39;) IMAGE\r#\rim = pg.screenshot(r\u0026#39;path\u0026#39;) # 截全屏并设置保存图片的位置和名称 print(im) # 打印图片的属性 # 不截全屏，截取区域图片。截取区域region参数为：左上角XY坐标值、宽度和高度 pg.screenshot(r\u0026#39;path\u0026#39;, region=(0, 0, 300, 400)) pix = pg.screenshot().getpixel((220, 200)) # 获取坐标(220,200)所在屏幕点的RGB颜色 positionStr = \u0026#39; RGB:(\u0026#39; + str(pix[0]).rjust(3) + \u0026#39;,\u0026#39; + str(pix[1]).rjust(3) + \u0026#39;,\u0026#39; + str(pix[2]).rjust(3) + \u0026#39;)\u0026#39; print(positionStr) # 打印结果为RGB:( 60, 63, 65) pix = pg.pixel(220, 200) # 获取坐标(220,200)所在屏幕点的RGB颜色与上面三行代码作用一样 positionStr = \u0026#39; RGB:(\u0026#39; + str(pix[0]).rjust(3) + \u0026#39;,\u0026#39; + str(pix[1]).rjust(3) + \u0026#39;,\u0026#39; + str(pix[2]).rjust(3) + \u0026#39;)\u0026#39; print(positionStr) # 打印结果为RGB:( 60, 63, 65) # 如果你只是要检验一下指定位置的像素值，可以用pixelMatchesColor(x,y,RGB)函数，把X、Y和RGB元组值穿入即可 # 如果所在屏幕中(x,y)点的实际RGB三色与函数中的RGB一样就会返回True，否则返回False # tolerance参数可以指定红、绿、蓝3种颜色误差范围 pg.pixelMatchesColor(100, 200, (255, 255, 255)) pg.pixelMatchesColor(100, 200, (255, 255, 245), tolerance=10) # 获得传入文件图片在现在的屏幕上面的坐标，返回的是一个元组(top, left, width, height) # 如果截图没找到，pg.locateOnScreen()函数返回None a = pg.locateOnScreen(r\u0026#39;file\u0026#39;) print(a) # 打印结果为Box(left=0, top=0, width=300, height=400) x, y = pg.center(a) # 获得文件图片在现在的屏幕上面的中心坐标 print(x, y) # 打印结果为150 200 x, y = pg.locateCenterOnScreen(r\u0026#39;file\u0026#39;) # 这步与上面的四行代码作用一样 print(x, y) # 打印结果为150 200 # 匹配屏幕所有与目标图片的对象，可以用for循环和list()输出 pg.locateAllOnScreen(r\u0026#39;file\u0026#39;) for pos in pg.locateAllOnScreen(r\u0026#39;file\u0026#39;): print(pos) # 打印结果为Box(left=0, top=0, width=300, height=400) a = list(pg.locateAllOnScreen(r\u0026#39;file\u0026#39;)) print(a) # 打印结果为[Box(left=0, top=0, width=300, height=400)] "},{"id":50,"href":"/docs/program-language/python/spider/requests/","title":"Requests","section":"Spider","content":"\rREQUESTS\r#\rimport requests,json res = requests.get(url,headers,params,json,verify=false,cookies,timeout) # params get请求传参 a=1 # data 非get请求提交数据, res.body的格式为 a=1\u0026amp;b=2 # json 提交数据，res.body的格式为 {“a”: 1, “b”: 2} res = res.text # 文本内容 res = res.content # 2进制内容 json.loads(json) # json数据 Requests\r#\rrequests.get() requests.post() requests.head() # 获取网页头的信息 requests.put() # 提交put请求 requests.delete() # 向HTML页码提交删除请求 requests.patch() # 向HTML网页提交局部修改请求 requests.get( url,headers,cookies,timeout, json, # 提交数据，res.body的格式为 {“a”: 1, “b”: 2} params, # get请求传参 a=1 data, # 非get请求提交数据, res.body的格式为 a=1\u0026amp;b=2 auth, # 元组，支持HTTP认证功能 files, # 字典类型，传输文件 proxies, # 字典类型，设定访问代理服务器，可以增加登录认证 allow_redirects, # True/False，默认为True，重定向开关 stream, # True/False， 默认为True，获取内容立刻下载开关 verify, # True/False，默认为True，认证SSL证书开关 cert # 本地SSL证书路径 ) Response\r#\r# cookie 获取处理cookie cookie = res.cookie cookkie = requests.utils.dict_from_cookiejar(cookies) res.encoding=\u0026#39;utf-8\u0026#39; # 解码/修改编码格式 res.content # 字节码返回值， 图片/视频等 res.text # 网页文档 字符串 res.status_code #状态码 res.url # 响应的url res.cookie # 获取cookie Session\r#\rsession = requests.session() # 维持会话 res = session.get() # 手动添加 cookie cookie = { \u0026#34;PHPSESSID\u0026#34;:\u0026#34;value\u0026#34; } req = requests.session() requests.utils.add_dict_to_cookiejar(req.cookies,cookie) req.get(url,cookies = cookie) BeautifulSoup4\nRE\nCSS_SELECTOR\nXPATH\n"},{"id":51,"href":"/docs/program-language/python/spider/selenium/","title":"Selenium","section":"Spider","content":"\rSELENIUM 4\r#\r驱动下载: Firefox Chrome Edge\n启动\r#\rfrom selenium import webdriver from selenium.webdriver.chrome.service import Service as ChromeService service = ChromeService(executable_path=CHROMEDRIVER_PATH) driver = webdriver.Chrome(service=service) 参数\r#\roption = webdriver.Options() options.add_argument(\u0026#39;user-agent=\u0026#34;value\u0026#34;\u0026#39;) # 添加UA options.add_argument(\u0026#39;window-size=1920x3000\u0026#39;) # 指定浏览器分辨率 options.add_argument(\u0026#39;--disable-gpu\u0026#39;) # 谷歌文档提到需要加上这个属性来规避bug options.add_argument(\u0026#39;--hide-scrollbars\u0026#39;) # 隐藏滚动条, 应对一些特殊页面 options.add_argument(\u0026#39;blink-settings=imagesEnabled=false\u0026#39;) # 不加载图片, 提升速度 options.add_argument(\u0026#39;--headless\u0026#39;) # 不提供可视化页面. linux系统不支持可视化不加这条会启动失败 options.add_argument(\u0026#39;--no-sandbox\u0026#39;) # 以最高权限运行 options.binary_location = r\u0026#34;path\u0026#34; # 手动指定使用的浏览器位置 options.add_extension(\u0026#39;crx\u0026#39;) # 添加 CRX 插件 options.add_argument(\u0026#34;--disable-javascript\u0026#34;) # 禁用JavaScript options.add_argument(\u0026#34;--proxy-server=http://XXXXX.com:80\u0026#34;) # 添加代理 # 设置开发者模式启动，该模式下webdriver属性为正常值 options.add_experimental_option(\u0026#39;excludeSwitches\u0026#39;, [\u0026#39;enable-automation\u0026#39;]) # 禁用浏览器弹窗 prefs = { \u0026#39;profile.default_content_setting_values\u0026#39; : { \u0026#39;notifications\u0026#39; : 2 } } options.add_experimental_option(\u0026#39;prefs\u0026#39;,prefs) driver=webdriver.Chrome(options=options) 元素定位\r#\rdriver.find_element(By.XPATH,\u0026#39;XPATH\u0026#39;) driver.find_element(By.CLASS_NAME,\u0026#39;CLASS_NAME\u0026#39;) driver.find_element(By.CSS_SELECTOR,\u0026#39;CSS_SELECTOR\u0026#39;) driver.find_element(By.ID,\u0026#39;ID\u0026#39;) driver.find_element(By.LINK_TEXT,\u0026#39;LINK_TEXT\u0026#39;) driver.find_element(By.PARTIAL_LINK_TEXT,\u0026#39;PARTIAL_LINK_TEXT\u0026#39;) driver.find_element(By.TAG_NAME,\u0026#39;TAG_NAME\u0026#39;) 查找多个元素，只需要将其中的 find_element 替换成 find_elements 即可。\n等待元素\r#\rfrom selenium.webdriver.support.ui import WebDriverWait el = WebDriverWait(driver, timeout=3).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) 动作API\r#\rclickable = driver.find_element(By.ID, \u0026#34;clickable\u0026#34;) ActionChains(driver)\\ .move_to_element(clickable)\\ .pause(1)\\ .click_and_hold()\\ .pause(1)\\ .click()\\ # 点击元素 .clear()\\ # 清除元素内的文本 .send_keys(\u0026#34;abc\u0026#34;)\\ # 写入文本 .perform() # 当前有动作执行时，可以使用以下方法停止这些动作， ActionBuilder(driver).clear_actions() # 释放所有动作 Keyboard\r#\rActionChains(driver)\\ # 按下 shift+abc .key_down(Keys.SHIFT)\\ .send_keys(\u0026#34;abc\u0026#34;)\\ .perform() ActionChains(driver)\\ # 浏览器输入某串字符（不指定元素） .send_keys(\u0026#34;abc\u0026#34;)\\ .perform() text_input = driver.find_element(By.ID, \u0026#34;textInput\u0026#34;) # 指定元素输入字符串 ActionChains(driver)\\ .send_keys_to_element(text_input, \u0026#34;abc\u0026#34;)\\ .perform() Mouse\r#\r# 鼠标点击保持，该方法将鼠标移动到元素中心与按下鼠标左键相结合。这有助于聚焦特定元素 clickable = driver.find_element(By.ID, \u0026#34;clickable\u0026#34;) ActionChains(driver)\\ .click_and_hold(clickable)\\ .perform() clickable = driver.find_element(By.ID, \u0026#34;click\u0026#34;) # 鼠标点击释放 ActionChains(driver)\\ .click(clickable)\\ .perform() # 鼠标定义的5种按键 # 0——鼠标左键 # 1——鼠标中键 # 2——鼠标右键 # MouseButton.BACK ---（后退键） # MouseButton.FORWARD ---（前进键） clickable = driver.find_element(By.ID, \u0026#34;clickable\u0026#34;) # 鼠标右击 ActionChains(driver)\\ .context_click(clickable)\\ .perform() action = ActionBuilder(driver) # 按下鼠标3键 action.pointer_action.pointer_down(MouseButton.BACK) action.pointer_action.pointer_up(MouseButton.BACK) action.perform() hoverable = driver.find_element(By.ID, \u0026#34;hover\u0026#34;) # 鼠标移动到元素上 ActionChains(driver)\\ .move_to_element(hoverable)\\ .perform() clickable = driver.find_element(By.ID, \u0026#34;clickable\u0026#34;) # 鼠标双击 ActionChains(driver)\\ .double_click(clickable)\\ .perform() # 拖拽元素 ## 单击并按住源元素，移动到目标元素的位置，然后释放鼠标 draggable = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) droppable = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) ActionChains(driver)\\ .drag_and_drop(draggable, droppable)\\ .perform() ## 通过位移拖拽 draggable = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) start = draggable.location finish = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;).location ActionChains(driver)\\ .drag_and_drop_by_offset(draggable, finish[\u0026#39;x\u0026#39;] - start[\u0026#39;x\u0026#39;], finish[\u0026#39;y\u0026#39;] - start[\u0026#39;y\u0026#39;])\\ .perform() Scroll\r#\rsupport chromedriver only\niframe = driver.find_element(By.TAG_NAME, \u0026#34;iframe\u0026#34;) # 滚动到某元素位置 ActionChains(driver)\\ .scroll_to_element(iframe)\\ .perform() footer = driver.find_element(By.TAG_NAME, \u0026#34;footer\u0026#34;) # 定量滚动 delta_y = footer.rect[\u0026#39;y\u0026#39;] ActionChains(driver)\\ .scroll_by_amount(0, delta_y)\\ .perform() iframe = driver.find_element(By.TAG_NAME, \u0026#34;iframe\u0026#34;) # 从一个元素滚动指定量 scroll_origin = ScrollOrigin.from_element(iframe) ActionChains(driver)\\ .scroll_from_origin(scroll_origin, 0, 200)\\ .perform() footer = driver.find_element(By.TAG_NAME, \u0026#34;footer\u0026#34;) # 从一个元素滚动，并指定位移 scroll_origin = ScrollOrigin.from_element(footer, 0, -50) ActionChains(driver)\\ .scroll_from_origin(scroll_origin, 0, 200)\\ .perform() ActionChains(driver)\\ # 从一个元素的原点位移 .scroll_from_origin(scroll_origin, 0, 200)\\ .perform() "},{"id":52,"href":"/docs/program-language/javascript/autojs/","title":"Autojs","section":"Javascript","content":"\rAUTOJS\r#\rAutojs 6 document ✈\r#\r"}]